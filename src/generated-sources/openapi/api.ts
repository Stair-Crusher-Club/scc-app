/* tslint:disable */
/* eslint-disable */
/**
 * Stair Crusher Club API Specification
 * ## 계단정복지도 서비스의 서버 - 클라이언트 통신을 위한 API 명세. 
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface AccessibilityInfoDto
 */
export interface AccessibilityInfoDto {
    /**
     * 
     * @type {BuildingAccessibility}
     * @memberof AccessibilityInfoDto
     */
    'buildingAccessibility'?: BuildingAccessibility;
    /**
     * 정보가 아직 채워지지 않았으면 empty list.
     * @type {Array<BuildingAccessibilityComment>}
     * @memberof AccessibilityInfoDto
     */
    'buildingAccessibilityComments': Array<BuildingAccessibilityComment>;
    /**
     * 
     * @type {PlaceAccessibility}
     * @memberof AccessibilityInfoDto
     */
    'placeAccessibility'?: PlaceAccessibility;
    /**
     * 정보가 아직 채워지지 않았으면 empty list.
     * @type {Array<PlaceAccessibilityComment>}
     * @memberof AccessibilityInfoDto
     */
    'placeAccessibilityComments': Array<PlaceAccessibilityComment>;
    /**
     * \'이 건물의 다른 점포 등록하기\'를 보여줄지 여부.
     * @type {boolean}
     * @memberof AccessibilityInfoDto
     */
    'hasOtherPlacesToRegisterInBuilding': boolean;
    /**
     * 내가 즐겨찾기한 장소인지 여부.
     * @type {boolean}
     * @memberof AccessibilityInfoDto
     */
    'isFavoritePlace': boolean;
    /**
     * 이 장소를 즐겨찾기한 사람 수.
     * @type {number}
     * @memberof AccessibilityInfoDto
     */
    'totalFavoriteCount': number;
}
/**
 * 
 * @export
 * @interface AccessibilityRankDto
 */
export interface AccessibilityRankDto {
    /**
     * 
     * @type {AccessibilityRegistererDto}
     * @memberof AccessibilityRankDto
     */
    'user': AccessibilityRegistererDto;
    /**
     * 접근성 정보를 등록한 장소의 수.
     * @type {number}
     * @memberof AccessibilityRankDto
     */
    'conqueredCount': number;
    /**
     * 현재 나의 랭크. 1부터 시작.
     * @type {number}
     * @memberof AccessibilityRankDto
     */
    'rank': number;
}
/**
 * 
 * @export
 * @interface AccessibilityRegistererDto
 */
export interface AccessibilityRegistererDto {
    /**
     * 
     * @type {string}
     * @memberof AccessibilityRegistererDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof AccessibilityRegistererDto
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof AccessibilityRegistererDto
     */
    'instagramId'?: string;
    /**
     * 클럽 멤버인지 여부
     * @type {boolean}
     * @memberof AccessibilityRegistererDto
     */
    'isClubMember'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const AccessibilityReportReason = {
    InaccurateInfo: 'INACCURATE_INFO',
    Closed: 'CLOSED',
    BadUser: 'BAD_USER'
} as const;

export type AccessibilityReportReason = typeof AccessibilityReportReason[keyof typeof AccessibilityReportReason];


/**
 * 
 * @export
 * @interface ApiErrorResponse
 */
export interface ApiErrorResponse {
    /**
     * reason for error
     * @type {string}
     * @memberof ApiErrorResponse
     */
    'msg'?: string;
    /**
     * 
     * @type {string}
     * @memberof ApiErrorResponse
     */
    'code'?: ApiErrorResponseCodeEnum;
}

export const ApiErrorResponseCodeEnum = {
    INTERNAL_FAILURE: '-999999',
    INVALID_AUTHENTICATION: '1',
    INVALID_NICKNAME: '2',
    INVALID_EMAIL: '3',
    INVALID_ARGUMENTS: '4',
    INVALID_PASSCODE: '10',
    ALREADY_JOINED: '11',
    CHALLENGE_NOT_OPENED: '12',
    CHALLENGE_CLOSED: '13',
    INVALID_BIRTH_YEAR: '14',
    B2B_INFO_REQUIRED: '15'
} as const;

export type ApiErrorResponseCodeEnum = typeof ApiErrorResponseCodeEnum[keyof typeof ApiErrorResponseCodeEnum];

/**
 * 
 * @export
 * @interface AuthTokensDto
 */
export interface AuthTokensDto {
    /**
     * 
     * @type {string}
     * @memberof AuthTokensDto
     */
    'accessToken': string;
}
/**
 * 건물 정보.
 * @export
 * @interface Building
 */
export interface Building {
    /**
     * 
     * @type {string}
     * @memberof Building
     */
    'id': string;
    /**
     * 건물의 human-readable한 주소.
     * @type {string}
     * @memberof Building
     */
    'address': string;
    /**
     * 
     * @type {Location}
     * @memberof Building
     */
    'location'?: Location;
}
/**
 * 건물의 접근성 정보.
 * @export
 * @interface BuildingAccessibility
 */
export interface BuildingAccessibility {
    /**
     * 
     * @type {string}
     * @memberof BuildingAccessibility
     */
    'id': string;
    /**
     * 
     * @type {StairInfo}
     * @memberof BuildingAccessibility
     */
    'entranceStairInfo': StairInfo;
    /**
     * 
     * @type {StairHeightLevel}
     * @memberof BuildingAccessibility
     */
    'entranceStairHeightLevel'?: StairHeightLevel;
    /**
     * 
     * @type {Array<string>}
     * @memberof BuildingAccessibility
     * @deprecated
     */
    'entranceImageUrls': Array<string>;
    /**
     * 
     * @type {Array<ImageDto>}
     * @memberof BuildingAccessibility
     */
    'entranceImages'?: Array<ImageDto>;
    /**
     * 
     * @type {Array<EntranceDoorType>}
     * @memberof BuildingAccessibility
     */
    'entranceDoorTypes'?: Array<EntranceDoorType>;
    /**
     * 
     * @type {boolean}
     * @memberof BuildingAccessibility
     */
    'hasSlope': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof BuildingAccessibility
     */
    'hasElevator': boolean;
    /**
     * 
     * @type {StairInfo}
     * @memberof BuildingAccessibility
     */
    'elevatorStairInfo': StairInfo;
    /**
     * 
     * @type {StairHeightLevel}
     * @memberof BuildingAccessibility
     */
    'elevatorStairHeightLevel'?: StairHeightLevel;
    /**
     * 
     * @type {Array<string>}
     * @memberof BuildingAccessibility
     * @deprecated
     */
    'elevatorImageUrls': Array<string>;
    /**
     * 
     * @type {Array<ImageDto>}
     * @memberof BuildingAccessibility
     */
    'elevatorImages'?: Array<ImageDto>;
    /**
     * 
     * @type {string}
     * @memberof BuildingAccessibility
     */
    'buildingId': string;
    /**
     * 익명으로 등록되었으면 null.
     * @type {string}
     * @memberof BuildingAccessibility
     */
    'registeredUserName'?: string;
    /**
     * 삭제 가능 여부
     * @type {boolean}
     * @memberof BuildingAccessibility
     */
    'isDeletable': boolean;
    /**
     * 
     * @type {ChallengeCrusherGroupDto}
     * @memberof BuildingAccessibility
     */
    'challengeCrusherGroup'?: ChallengeCrusherGroupDto;
    /**
     * 유저가 이 접근성 정보에 \'도움이 돼요\'를 표시했는지 여부.
     * @type {boolean}
     * @memberof BuildingAccessibility
     */
    'isUpvoted': boolean;
    /**
     * 이 접근성 정보가 \'도움이 돼요\'를 받은 총 횟수. 이 숫자에 따라 버튼 텍스트에 \'도움이 돼요\'나 \'정확한 정보에요\'를 사용한다.
     * @type {number}
     * @memberof BuildingAccessibility
     */
    'totalUpvoteCount': number;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof BuildingAccessibility
     */
    'createdAt': EpochMillisTimestamp;
}
/**
 * 건물에 대한 의견. 익명으로 달린 댓글이면 user 가 null 이다.
 * @export
 * @interface BuildingAccessibilityComment
 */
export interface BuildingAccessibilityComment {
    /**
     * 
     * @type {string}
     * @memberof BuildingAccessibilityComment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof BuildingAccessibilityComment
     */
    'buildingId': string;
    /**
     * 
     * @type {AccessibilityRegistererDto}
     * @memberof BuildingAccessibilityComment
     */
    'user'?: AccessibilityRegistererDto;
    /**
     * 
     * @type {string}
     * @memberof BuildingAccessibilityComment
     */
    'comment': string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof BuildingAccessibilityComment
     */
    'createdAt': EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface CancelBuildingAccessibilityUpvoteRequestDto
 */
export interface CancelBuildingAccessibilityUpvoteRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CancelBuildingAccessibilityUpvoteRequestDto
     */
    'buildingAccessibilityId': string;
}
/**
 * 
 * @export
 * @interface CancelPlaceAccessibilityUpvoteRequestDto
 */
export interface CancelPlaceAccessibilityUpvoteRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CancelPlaceAccessibilityUpvoteRequestDto
     */
    'placeAccessibilityId': string;
}
/**
 * 
 * @export
 * @interface CancelUpvoteRequestDto
 */
export interface CancelUpvoteRequestDto {
    /**
     * 
     * @type {UpvoteTargetTypeDto}
     * @memberof CancelUpvoteRequestDto
     */
    'targetType': UpvoteTargetTypeDto;
    /**
     * 
     * @type {string}
     * @memberof CancelUpvoteRequestDto
     */
    'id': string;
}
/**
 * B2B 챌린지 입장 시 받아야 하는 폼의 개별 필드 정의
 * @export
 * @interface ChallengeB2bFormAvailableFieldDto
 */
export interface ChallengeB2bFormAvailableFieldDto {
    /**
     * 
     * @type {ChallengeB2bFormAvailableFieldNameTypeDto}
     * @memberof ChallengeB2bFormAvailableFieldDto
     */
    'name': ChallengeB2bFormAvailableFieldNameTypeDto;
    /**
     * SELECT 타입 필드의 선택 옵션 목록 (SELECT 타입인 경우에만 존재)
     * @type {Array<string>}
     * @memberof ChallengeB2bFormAvailableFieldDto
     */
    'options'?: Array<string>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChallengeB2bFormAvailableFieldNameTypeDto = {
    ParticipantName: 'participantName',
    CompanyName: 'companyName',
    OrganizationName: 'organizationName',
    EmployeeIdentificationNumber: 'employeeIdentificationNumber'
} as const;

export type ChallengeB2bFormAvailableFieldNameTypeDto = typeof ChallengeB2bFormAvailableFieldNameTypeDto[keyof typeof ChallengeB2bFormAvailableFieldNameTypeDto];


/**
 * B2B 챌린지의 동적 폼 설정
 * @export
 * @interface ChallengeB2bFormSchemaDto
 */
export interface ChallengeB2bFormSchemaDto {
    /**
     * 표시할 폼 필드 목록
     * @type {Array<ChallengeB2bFormAvailableFieldDto>}
     * @memberof ChallengeB2bFormSchemaDto
     */
    'availableFields'?: Array<ChallengeB2bFormAvailableFieldDto>;
}
/**
 * 
 * @export
 * @interface ChallengeCrusherGroupDto
 */
export interface ChallengeCrusherGroupDto {
    /**
     * 
     * @type {ImageDto}
     * @memberof ChallengeCrusherGroupDto
     */
    'icon'?: ImageDto;
    /**
     * 
     * @type {string}
     * @memberof ChallengeCrusherGroupDto
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface ChallengeDto
 */
export interface ChallengeDto {
    /**
     * 
     * @type {string}
     * @memberof ChallengeDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ChallengeDto
     */
    'name': string;
    /**
     * 
     * @type {ChallengeStatusDto}
     * @memberof ChallengeDto
     */
    'status': ChallengeStatusDto;
    /**
     * 
     * @type {boolean}
     * @memberof ChallengeDto
     */
    'isPublic': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ChallengeDto
     */
    'isComplete': boolean;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ChallengeDto
     */
    'startsAt': EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ChallengeDto
     */
    'endsAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {number}
     * @memberof ChallengeDto
     */
    'goal': number;
    /**
     * 
     * @type {Array<number>}
     * @memberof ChallengeDto
     */
    'milestones': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof ChallengeDto
     */
    'participationsCount': number;
    /**
     * 
     * @type {number}
     * @memberof ChallengeDto
     */
    'contributionsCount': number;
    /**
     * 
     * @type {string}
     * @memberof ChallengeDto
     */
    'description': string;
    /**
     * 
     * @type {ChallengeCrusherGroupDto}
     * @memberof ChallengeDto
     */
    'crusherGroup'?: ChallengeCrusherGroupDto;
    /**
     * B2B 챌린지인지 여부
     * @type {boolean}
     * @memberof ChallengeDto
     */
    'isB2B'?: boolean;
    /**
     * 
     * @type {ChallengeB2bFormSchemaDto}
     * @memberof ChallengeDto
     */
    'b2bFormSchema'?: ChallengeB2bFormSchemaDto;
}
/**
 * 선택형 필드의 옵션
 * @export
 * @interface ChallengeFormFieldOptionDto
 */
export interface ChallengeFormFieldOptionDto {
    /**
     * 실제 저장될 값
     * @type {string}
     * @memberof ChallengeFormFieldOptionDto
     */
    'value': string;
    /**
     * 사용자에게 표시될 라벨
     * @type {string}
     * @memberof ChallengeFormFieldOptionDto
     */
    'label': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChallengeFormFieldTypeDto = {
    Text: 'TEXT',
    Select: 'SELECT'
} as const;

export type ChallengeFormFieldTypeDto = typeof ChallengeFormFieldTypeDto[keyof typeof ChallengeFormFieldTypeDto];


/**
 * 
 * @export
 * @enum {string}
 */

export const ChallengeQuestCompleteStampTypeDto = {
    Flag: 'FLAG',
    Cafe: 'CAFE',
    ThumbsUp: 'THUMBS_UP',
    Potion: 'POTION',
    Restaurant: 'RESTAURANT',
    Review: 'REVIEW'
} as const;

export type ChallengeQuestCompleteStampTypeDto = typeof ChallengeQuestCompleteStampTypeDto[keyof typeof ChallengeQuestCompleteStampTypeDto];


/**
 * 
 * @export
 * @interface ChallengeQuestDto
 */
export interface ChallengeQuestDto {
    /**
     * 퀘스트 ID
     * @type {string}
     * @memberof ChallengeQuestDto
     */
    'id': string;
    /**
     * 퀘스트 제목
     * @type {string}
     * @memberof ChallengeQuestDto
     */
    'title': string;
    /**
     * 퀘스트 설명
     * @type {string}
     * @memberof ChallengeQuestDto
     */
    'description': string;
    /**
     * 목표 완료 개수
     * @type {number}
     * @memberof ChallengeQuestDto
     */
    'targetCount': number;
    /**
     * 현재 완료한 개수 (참여하지 않은 경우 0)
     * @type {number}
     * @memberof ChallengeQuestDto
     */
    'completedCount': number;
    /**
     * 
     * @type {ChallengeQuestCompleteStampTypeDto}
     * @memberof ChallengeQuestDto
     */
    'completeStampType': ChallengeQuestCompleteStampTypeDto;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ChallengeQuestDto
     */
    'completedAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ChallengeQuestDto
     */
    'startDate'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ChallengeQuestDto
     */
    'endDate'?: EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface ChallengeRankDto
 */
export interface ChallengeRankDto {
    /**
     * 현재 랭크. 1부터 시작.
     * @type {number}
     * @memberof ChallengeRankDto
     */
    'rank': number;
    /**
     * 챌린지 안에서 이룬 성과. ex) 365 개 정복
     * @type {number}
     * @memberof ChallengeRankDto
     */
    'contributionCount': number;
    /**
     * 성과를 이룬 유저 이름.
     * @type {string}
     * @memberof ChallengeRankDto
     */
    'nickname': string;
    /**
     * B2B 챌린지의 경우, 회사 이름.
     * @type {string}
     * @memberof ChallengeRankDto
     */
    'companyName'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ChallengeStatusDto = {
    InProgress: 'InProgress',
    Upcoming: 'Upcoming',
    Closed: 'Closed'
} as const;

export type ChallengeStatusDto = typeof ChallengeStatusDto[keyof typeof ChallengeStatusDto];


/**
 * 
 * @export
 * @interface CircleSearchRegionDto
 */
export interface CircleSearchRegionDto {
    /**
     * 
     * @type {Location}
     * @memberof CircleSearchRegionDto
     */
    'currentLocation': Location;
    /**
     * 
     * @type {number}
     * @memberof CircleSearchRegionDto
     */
    'distanceMetersLimit': number;
}
/**
 * 
 * @export
 * @interface CompactAccessibilityInfoDto
 */
export interface CompactAccessibilityInfoDto {
    /**
     * 접근성 점수. 접근성 정보가 없는 경우 null
     * @type {number}
     * @memberof CompactAccessibilityInfoDto
     */
    'accessibilityScore'?: number;
    /**
     * 
     * @type {Array<string>}
     * @memberof CompactAccessibilityInfoDto
     */
    'imageUrls': Array<string>;
    /**
     * 
     * @type {Array<ImageDto>}
     * @memberof CompactAccessibilityInfoDto
     */
    'images': Array<ImageDto>;
    /**
     * 
     * @type {boolean}
     * @memberof CompactAccessibilityInfoDto
     */
    'hasSlope': boolean;
    /**
     * 
     * @type {Array<number>}
     * @memberof CompactAccessibilityInfoDto
     */
    'floors': Array<number>;
    /**
     * 
     * @type {number}
     * @memberof CompactAccessibilityInfoDto
     */
    'reviewCount'?: number;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof CompactAccessibilityInfoDto
     */
    'createdAt'?: EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface ContributedChallengeInfoDto
 */
export interface ContributedChallengeInfoDto {
    /**
     * 
     * @type {ChallengeDto}
     * @memberof ContributedChallengeInfoDto
     */
    'challenge': ChallengeDto;
    /**
     * 이번 유저 참여로 인해 달성된 퀘스트 목록.
     * @type {Array<ChallengeQuestDto>}
     * @memberof ContributedChallengeInfoDto
     */
    'completedQuestsByContribution': Array<ChallengeQuestDto>;
}
/**
 * 
 * @export
 * @interface CreateAnonymousUserResponseDto
 */
export interface CreateAnonymousUserResponseDto {
    /**
     * 
     * @type {AuthTokensDto}
     * @memberof CreateAnonymousUserResponseDto
     */
    'authTokens': AuthTokensDto;
    /**
     * 
     * @type {string}
     * @memberof CreateAnonymousUserResponseDto
     */
    'userId': string;
}
/**
 * 
 * @export
 * @interface CreatePlaceFavoriteRequestDto
 */
export interface CreatePlaceFavoriteRequestDto {
    /**
     * 
     * @type {string}
     * @memberof CreatePlaceFavoriteRequestDto
     */
    'placeId': string;
}
/**
 * 
 * @export
 * @interface CreatePlaceFavoriteResponseDto
 */
export interface CreatePlaceFavoriteResponseDto {
    /**
     * 
     * @type {number}
     * @memberof CreatePlaceFavoriteResponseDto
     */
    'totalPlaceFavoriteCount': number;
    /**
     * 
     * @type {PlaceFavorite}
     * @memberof CreatePlaceFavoriteResponseDto
     */
    'placeFavorite': PlaceFavorite;
}
/**
 * 
 * @export
 * @interface CrusherClubActivityLogDto
 */
export interface CrusherClubActivityLogDto {
    /**
     * 활동 ID
     * @type {string}
     * @memberof CrusherClubActivityLogDto
     */
    'id': string;
    /**
     * 활동 제목
     * @type {string}
     * @memberof CrusherClubActivityLogDto
     */
    'title': string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof CrusherClubActivityLogDto
     */
    'activityDoneAt': EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof CrusherClubActivityLogDto
     */
    'canceledAt'?: EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CrusherClubCrewTypeDto = {
    EditorCrew: 'EDITOR_CREW',
    CrusherCrew: 'CRUSHER_CREW'
} as const;

export type CrusherClubCrewTypeDto = typeof CrusherClubCrewTypeDto[keyof typeof CrusherClubCrewTypeDto];


/**
 * 
 * @export
 * @interface CrusherClubDto
 */
export interface CrusherClubDto {
    /**
     * 시즌 (예: 25년 가을)
     * @type {string}
     * @memberof CrusherClubDto
     */
    'season': string;
    /**
     * 시작 일시 (yyyy-MM-dd)
     * @type {string}
     * @memberof CrusherClubDto
     */
    'startDate': string;
    /**
     * 종료 일시 (yyyy-MM-dd)
     * @type {string}
     * @memberof CrusherClubDto
     */
    'endDate': string;
    /**
     * 
     * @type {CrusherClubCrewTypeDto}
     * @memberof CrusherClubDto
     */
    'crewType': CrusherClubCrewTypeDto;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CrusherClubQuestCompleteStampTypeDto = {
    StartingDay: 'STARTING_DAY',
    ShortReview1: 'SHORT_REVIEW_1',
    ShortReview2: 'SHORT_REVIEW_2',
    ShortReview3: 'SHORT_REVIEW_3',
    ShortReview4: 'SHORT_REVIEW_4',
    ShortReview5: 'SHORT_REVIEW_5',
    ShortReview6: 'SHORT_REVIEW_6',
    LongReview1: 'LONG_REVIEW_1',
    LongReview2: 'LONG_REVIEW_2',
    AppUsageReview: 'APP_USAGE_REVIEW',
    ConquerQuest: 'CONQUER_QUEST',
    WarmingUpConquer: 'WARMING_UP_CONQUER',
    Conquer1: 'CONQUER_1',
    Conquer2: 'CONQUER_2',
    Conquer3: 'CONQUER_3',
    Conquer4: 'CONQUER_4',
    DailyLifeQuest: 'DAILY_LIFE_QUEST'
} as const;

export type CrusherClubQuestCompleteStampTypeDto = typeof CrusherClubQuestCompleteStampTypeDto[keyof typeof CrusherClubQuestCompleteStampTypeDto];


/**
 * 
 * @export
 * @interface CrusherClubQuestDto
 */
export interface CrusherClubQuestDto {
    /**
     * 퀘스트 ID
     * @type {string}
     * @memberof CrusherClubQuestDto
     */
    'id': string;
    /**
     * 퀘스트 제목
     * @type {string}
     * @memberof CrusherClubQuestDto
     */
    'title': string;
    /**
     * 
     * @type {CrusherClubQuestCompleteStampTypeDto}
     * @memberof CrusherClubQuestDto
     */
    'completeStampType': CrusherClubQuestCompleteStampTypeDto;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof CrusherClubQuestDto
     */
    'completedAt'?: EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const CrusherClubQuestTypeDto = {
    StartingDay: 'STARTING_DAY',
    ShortReview: 'SHORT_REVIEW',
    LongReview: 'LONG_REVIEW',
    AppUsageReview: 'APP_USAGE_REVIEW',
    ConquerQuest: 'CONQUER_QUEST',
    WarmingUpConquer: 'WARMING_UP_CONQUER',
    Conquer: 'CONQUER',
    DailyLifeQuest: 'DAILY_LIFE_QUEST'
} as const;

export type CrusherClubQuestTypeDto = typeof CrusherClubQuestTypeDto[keyof typeof CrusherClubQuestTypeDto];


/**
 * 
 * @export
 * @interface CurrentCrusherActivityDto
 */
export interface CurrentCrusherActivityDto {
    /**
     * 
     * @type {CrusherClubDto}
     * @memberof CurrentCrusherActivityDto
     */
    'crusherClub': CrusherClubDto;
    /**
     * 
     * @type {Array<CrusherClubQuestDto>}
     * @memberof CurrentCrusherActivityDto
     */
    'quests': Array<CrusherClubQuestDto>;
    /**
     * 사용자의 활동 로그
     * @type {Array<CrusherClubActivityLogDto>}
     * @memberof CurrentCrusherActivityDto
     */
    'activityLogs'?: Array<CrusherClubActivityLogDto>;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const DayOfWeek = {
    Sunday: 'SUNDAY',
    Monday: 'MONDAY',
    Tuesday: 'TUESDAY',
    Wednesday: 'WEDNESDAY',
    Thursday: 'THURSDAY',
    Friday: 'FRIDAY',
    Saturday: 'SATURDAY'
} as const;

export type DayOfWeek = typeof DayOfWeek[keyof typeof DayOfWeek];


/**
 * 
 * @export
 * @interface DeleteBuildingAccessibilityPostRequest
 */
export interface DeleteBuildingAccessibilityPostRequest {
    /**
     * 삭제할 건물 정보의 아이디
     * @type {string}
     * @memberof DeleteBuildingAccessibilityPostRequest
     */
    'buildingAccessibilityId': string;
}
/**
 * 
 * @export
 * @interface DeletePlaceAccessibilityPostRequest
 */
export interface DeletePlaceAccessibilityPostRequest {
    /**
     * 삭제할 장소 정보의 아이디
     * @type {string}
     * @memberof DeletePlaceAccessibilityPostRequest
     */
    'placeAccessibilityId': string;
}
/**
 * 
 * @export
 * @interface DeletePlaceFavoriteRequestDto
 */
export interface DeletePlaceFavoriteRequestDto {
    /**
     * 
     * @type {string}
     * @memberof DeletePlaceFavoriteRequestDto
     */
    'placeId': string;
}
/**
 * 
 * @export
 * @interface DeletePlaceFavoriteResponseDto
 */
export interface DeletePlaceFavoriteResponseDto {
    /**
     * 
     * @type {number}
     * @memberof DeletePlaceFavoriteResponseDto
     */
    'totalPlaceFavoriteCount': number;
}
/**
 * 
 * @export
 * @interface DeletePlaceReviewPostRequest
 */
export interface DeletePlaceReviewPostRequest {
    /**
     * 삭제할 장소 리뷰의 아이디
     * @type {string}
     * @memberof DeletePlaceReviewPostRequest
     */
    'placeReviewId': string;
}
/**
 * 
 * @export
 * @interface DeleteToiletReviewPostRequest
 */
export interface DeleteToiletReviewPostRequest {
    /**
     * 삭제할 화장실 리뷰의 아이디
     * @type {string}
     * @memberof DeleteToiletReviewPostRequest
     */
    'toiletReviewId': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const EntranceDoorType = {
    None: 'None',
    Hinged: 'Hinged',
    Sliding: 'Sliding',
    Revolving: 'Revolving',
    Automatic: 'Automatic',
    Etc: 'ETC'
} as const;

export type EntranceDoorType = typeof EntranceDoorType[keyof typeof EntranceDoorType];


/**
 * 특정 시각을 표현하기 위한 모델.
 * @export
 * @interface EpochMillisTimestamp
 */
export interface EpochMillisTimestamp {
    /**
     * 
     * @type {number}
     * @memberof EpochMillisTimestamp
     */
    'value': number;
}
/**
 * 읍면동을 표현하기 위한 모델.
 * @export
 * @interface EupMyeonDong
 */
export interface EupMyeonDong {
    /**
     * 
     * @type {string}
     * @memberof EupMyeonDong
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof EupMyeonDong
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof EupMyeonDong
     */
    'siGunGuId': string;
}
/**
 * 
 * @export
 * @interface ExternalAccessibility
 */
export interface ExternalAccessibility {
    /**
     * 
     * @type {string}
     * @memberof ExternalAccessibility
     */
    'id': string;
    /**
     * 장소의 human-readable한 이름.
     * @type {string}
     * @memberof ExternalAccessibility
     */
    'name': string;
    /**
     * 장소의 human-readable한 주소.
     * @type {string}
     * @memberof ExternalAccessibility
     */
    'address'?: string;
    /**
     * 
     * @type {Location}
     * @memberof ExternalAccessibility
     */
    'location': Location;
    /**
     * 장소의 종류
     * @type {string}
     * @memberof ExternalAccessibility
     */
    'category': string;
    /**
     * 
     * @type {ToiletAccessibilityDetails}
     * @memberof ExternalAccessibility
     */
    'toilet_details'?: ToiletAccessibilityDetails;
}
/**
 * 
 * @export
 * @interface GetAccessibilityActivityReportResponseDto
 */
export interface GetAccessibilityActivityReportResponseDto {
    /**
     * 오늘 정복한 장소/건물 수
     * @type {number}
     * @memberof GetAccessibilityActivityReportResponseDto
     */
    'todayConqueredCount': number;
    /**
     * 이번달 정복한 장소/건물 수
     * @type {number}
     * @memberof GetAccessibilityActivityReportResponseDto
     */
    'thisMonthConqueredCount': number;
    /**
     * 이번주 정복한 요일들 일요일(0) - 토요일(6)
     * @type {Array<DayOfWeek>}
     * @memberof GetAccessibilityActivityReportResponseDto
     */
    'thisWeekConqueredWeekdays': Array<DayOfWeek>;
}
/**
 * 
 * @export
 * @interface GetAccessibilityLeaderboardPost200Response
 */
export interface GetAccessibilityLeaderboardPost200Response {
    /**
     * 
     * @type {Array<AccessibilityRankDto>}
     * @memberof GetAccessibilityLeaderboardPost200Response
     */
    'ranks': Array<AccessibilityRankDto>;
}
/**
 * 
 * @export
 * @interface GetAccessibilityPostRequest
 */
export interface GetAccessibilityPostRequest {
    /**
     * 
     * @type {string}
     * @memberof GetAccessibilityPostRequest
     */
    'placeId': string;
}
/**
 * 
 * @export
 * @interface GetAccessibilityRankPost200Response
 */
export interface GetAccessibilityRankPost200Response {
    /**
     * 
     * @type {AccessibilityRankDto}
     * @memberof GetAccessibilityRankPost200Response
     */
    'accessibilityRank': AccessibilityRankDto;
}
/**
 * 
 * @export
 * @interface GetChallengeRequestDto
 */
export interface GetChallengeRequestDto {
    /**
     * 
     * @type {string}
     * @memberof GetChallengeRequestDto
     */
    'challengeId': string;
}
/**
 * 
 * @export
 * @interface GetChallengeResponseDto
 */
export interface GetChallengeResponseDto {
    /**
     * 
     * @type {ChallengeDto}
     * @memberof GetChallengeResponseDto
     */
    'challenge': ChallengeDto;
    /**
     * 
     * @type {ChallengeRankDto}
     * @memberof GetChallengeResponseDto
     */
    'myRank'?: ChallengeRankDto;
    /**
     * 
     * @type {Array<ChallengeRankDto>}
     * @memberof GetChallengeResponseDto
     */
    'ranks': Array<ChallengeRankDto>;
    /**
     * 다음 랭크에 도달하기 위해 필요한 contribution 수. ex) 10개 정복
     * @type {number}
     * @memberof GetChallengeResponseDto
     */
    'contributionCountForNextRank'?: number;
    /**
     * 내가 참여하고 있는지에 대한 정보
     * @type {boolean}
     * @memberof GetChallengeResponseDto
     */
    'hasJoined': boolean;
    /**
     * 참여코드를 입력해야만 참여할 수 있는 챌린지인지
     * @type {boolean}
     * @memberof GetChallengeResponseDto
     */
    'hasPasscode': boolean;
    /**
     * B2B 챌린지인지 (회사명과 참가자명을 입력받을지 결정)
     * @type {boolean}
     * @memberof GetChallengeResponseDto
     */
    'isB2B': boolean;
    /**
     * 챌린지의 퀘스트 목록 (진행 현황 포함)
     * @type {Array<ChallengeQuestDto>}
     * @memberof GetChallengeResponseDto
     */
    'quests': Array<ChallengeQuestDto>;
}
/**
 * 
 * @export
 * @interface GetChallengeWithInvitationCodeRequestDto
 */
export interface GetChallengeWithInvitationCodeRequestDto {
    /**
     * 공개되어있지 않은, 초대코드로만 볼 수 있는 챌린지
     * @type {string}
     * @memberof GetChallengeWithInvitationCodeRequestDto
     */
    'invitationCode': string;
}
/**
 * 
 * @export
 * @interface GetClientVersionStatusRequestDto
 */
export interface GetClientVersionStatusRequestDto {
    /**
     * 현재 클라이언트 버전 ex) 3.37.0
     * @type {string}
     * @memberof GetClientVersionStatusRequestDto
     */
    'version': string;
}
/**
 * 
 * @export
 * @interface GetClientVersionStatusResponseDto
 */
export interface GetClientVersionStatusResponseDto {
    /**
     * 
     * @type {string}
     * @memberof GetClientVersionStatusResponseDto
     */
    'status': GetClientVersionStatusResponseDtoStatusEnum;
    /**
     * 강제 업데이트 혹은 업데이트 권장 사유
     * @type {string}
     * @memberof GetClientVersionStatusResponseDto
     */
    'message'?: string;
}

export const GetClientVersionStatusResponseDtoStatusEnum = {
    Stable: 'STABLE',
    UpgradeNeeded: 'UPGRADE_NEEDED',
    UpgradeRecommended: 'UPGRADE_RECOMMENDED'
} as const;

export type GetClientVersionStatusResponseDtoStatusEnum = typeof GetClientVersionStatusResponseDtoStatusEnum[keyof typeof GetClientVersionStatusResponseDtoStatusEnum];

/**
 * 
 * @export
 * @interface GetCountForNextRankPost200Response
 */
export interface GetCountForNextRankPost200Response {
    /**
     * 
     * @type {number}
     * @memberof GetCountForNextRankPost200Response
     */
    'countForNextRank': number;
}
/**
 * 
 * @export
 * @interface GetCurrentCrusherActivityResponseDto
 */
export interface GetCurrentCrusherActivityResponseDto {
    /**
     * 
     * @type {CurrentCrusherActivityDto}
     * @memberof GetCurrentCrusherActivityResponseDto
     */
    'currentCrusherActivity'?: CurrentCrusherActivityDto;
}
/**
 * 
 * @export
 * @interface GetExternalAccessibilityPostRequest
 */
export interface GetExternalAccessibilityPostRequest {
    /**
     * 
     * @type {string}
     * @memberof GetExternalAccessibilityPostRequest
     */
    'externalAccessibilityId': string;
}
/**
 * 
 * @export
 * @interface GetHomeBannersResponseDto
 */
export interface GetHomeBannersResponseDto {
    /**
     * 
     * @type {Array<HomeBannerDto>}
     * @memberof GetHomeBannersResponseDto
     */
    'banners': Array<HomeBannerDto>;
}
/**
 * 
 * @export
 * @interface GetImageUploadUrlsPost200ResponseInner
 */
export interface GetImageUploadUrlsPost200ResponseInner {
    /**
     * 
     * @type {string}
     * @memberof GetImageUploadUrlsPost200ResponseInner
     */
    'url': string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof GetImageUploadUrlsPost200ResponseInner
     */
    'expireAt': EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface GetImageUploadUrlsPostRequest
 */
export interface GetImageUploadUrlsPostRequest {
    /**
     * 업로드할 이미지 수.
     * @type {number}
     * @memberof GetImageUploadUrlsPostRequest
     */
    'count': number;
    /**
     * 업로드할 이미지의 확장자. \'.\'을 붙이지 말아야 한다. e.g. png, jpeg 등.
     * @type {string}
     * @memberof GetImageUploadUrlsPostRequest
     */
    'filenameExtension': string;
    /**
     * 
     * @type {ImageUploadPurpose}
     * @memberof GetImageUploadUrlsPostRequest
     */
    'purposeType'?: ImageUploadPurpose;
}
/**
 * 
 * @export
 * @interface GetNearbyAccessibilityStatusPost200Response
 */
export interface GetNearbyAccessibilityStatusPost200Response {
    /**
     * 
     * @type {number}
     * @memberof GetNearbyAccessibilityStatusPost200Response
     */
    'conqueredCount'?: number;
}
/**
 * 
 * @export
 * @interface GetNearbyAccessibilityStatusPostRequest
 */
export interface GetNearbyAccessibilityStatusPostRequest {
    /**
     * 
     * @type {Location}
     * @memberof GetNearbyAccessibilityStatusPostRequest
     */
    'currentLocation': Location;
    /**
     * 
     * @type {number}
     * @memberof GetNearbyAccessibilityStatusPostRequest
     */
    'distanceMetersLimit': number;
}
/**
 * 
 * @export
 * @interface GetUserInfoResponseDto
 */
export interface GetUserInfoResponseDto {
    /**
     * 
     * @type {User}
     * @memberof GetUserInfoResponseDto
     */
    'user': User;
    /**
     * 유저의 플래그들. ex) [ \"MAP_VISIBLE\" ]
     * @type {Array<string>}
     * @memberof GetUserInfoResponseDto
     */
    'flags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface GiveBuildingAccessibilityUpvoteRequestDto
 */
export interface GiveBuildingAccessibilityUpvoteRequestDto {
    /**
     * 
     * @type {string}
     * @memberof GiveBuildingAccessibilityUpvoteRequestDto
     */
    'buildingAccessibilityId': string;
}
/**
 * 
 * @export
 * @interface GivePlaceAccessibilityUpvoteRequestDto
 */
export interface GivePlaceAccessibilityUpvoteRequestDto {
    /**
     * 
     * @type {string}
     * @memberof GivePlaceAccessibilityUpvoteRequestDto
     */
    'placeAccessibilityId': string;
}
/**
 * 
 * @export
 * @interface GiveUpvoteRequestDto
 */
export interface GiveUpvoteRequestDto {
    /**
     * 
     * @type {UpvoteTargetTypeDto}
     * @memberof GiveUpvoteRequestDto
     */
    'targetType': UpvoteTargetTypeDto;
    /**
     * 
     * @type {string}
     * @memberof GiveUpvoteRequestDto
     */
    'id': string;
}
/**
 * 
 * @export
 * @interface HomeBannerDto
 */
export interface HomeBannerDto {
    /**
     * 
     * @type {string}
     * @memberof HomeBannerDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof HomeBannerDto
     */
    'loggingKey': string;
    /**
     * 
     * @type {string}
     * @memberof HomeBannerDto
     */
    'imageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof HomeBannerDto
     */
    'clickPageUrl': string;
    /**
     * 
     * @type {string}
     * @memberof HomeBannerDto
     */
    'clickPageTitle': string;
}
/**
 * 
 * @export
 * @interface ImageDto
 */
export interface ImageDto {
    /**
     * 
     * @type {string}
     * @memberof ImageDto
     */
    'imageUrl': string;
    /**
     * 원본 이미지의 width
     * @type {number}
     * @memberof ImageDto
     */
    'imageWidth'?: number;
    /**
     * 원본 이미지의 height
     * @type {number}
     * @memberof ImageDto
     */
    'imageHeight'?: number;
    /**
     * 아직 썸네일이 생성되지 않았다면 null
     * @type {string}
     * @memberof ImageDto
     */
    'thumbnailUrl'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ImageUploadPurpose = {
    Accessibility: 'ACCESSIBILITY',
    PlaceReview: 'PLACE_REVIEW',
    ToiletReview: 'TOILET_REVIEW'
} as const;

export type ImageUploadPurpose = typeof ImageUploadPurpose[keyof typeof ImageUploadPurpose];


/**
 * B2B 챌린지 참여 시 회사 정보를 입력 받는 DTO.
 * @export
 * @interface JoinChallengeRequestCompanyJoinInfoDto
 */
export interface JoinChallengeRequestCompanyJoinInfoDto {
    /**
     * 회사명
     * @type {string}
     * @memberof JoinChallengeRequestCompanyJoinInfoDto
     */
    'companyName'?: string;
    /**
     * 본인의 이름
     * @type {string}
     * @memberof JoinChallengeRequestCompanyJoinInfoDto
     */
    'participantName'?: string;
    /**
     * 조직명
     * @type {string}
     * @memberof JoinChallengeRequestCompanyJoinInfoDto
     */
    'organizationName'?: string;
    /**
     * 사원번호
     * @type {string}
     * @memberof JoinChallengeRequestCompanyJoinInfoDto
     */
    'employeeIdentificationNumber'?: string;
}
/**
 * 
 * @export
 * @interface JoinChallengeRequestDto
 */
export interface JoinChallengeRequestDto {
    /**
     * 
     * @type {string}
     * @memberof JoinChallengeRequestDto
     */
    'challengeId': string;
    /**
     * 참여코드를 입력해야만 참여가 가능한 챌린지에 한해서 필요
     * @type {string}
     * @memberof JoinChallengeRequestDto
     */
    'passcode'?: string;
    /**
     * 
     * @type {JoinChallengeRequestCompanyJoinInfoDto}
     * @memberof JoinChallengeRequestDto
     */
    'companyInfo'?: JoinChallengeRequestCompanyJoinInfoDto;
}
/**
 * 
 * @export
 * @interface JoinChallengeResponseDto
 */
export interface JoinChallengeResponseDto {
    /**
     * 
     * @type {ChallengeDto}
     * @memberof JoinChallengeResponseDto
     */
    'challenge': ChallengeDto;
    /**
     * 10위권까지의 랭킹 정보
     * @type {Array<ChallengeRankDto>}
     * @memberof JoinChallengeResponseDto
     */
    'ranks': Array<ChallengeRankDto>;
}
/**
 * 
 * @export
 * @interface KakaoTokensDto
 */
export interface KakaoTokensDto {
    /**
     * 
     * @type {string}
     * @memberof KakaoTokensDto
     */
    'accessToken': string;
    /**
     * 
     * @type {string}
     * @memberof KakaoTokensDto
     */
    'refreshToken': string;
    /**
     * 
     * @type {string}
     * @memberof KakaoTokensDto
     */
    'idToken': string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof KakaoTokensDto
     */
    'accessTokenExpiresAt'?: EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof KakaoTokensDto
     */
    'refreshTokenExpiresAt'?: EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface ListChallengesItemDto
 */
export interface ListChallengesItemDto {
    /**
     * 
     * @type {string}
     * @memberof ListChallengesItemDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof ListChallengesItemDto
     */
    'name': string;
    /**
     * 
     * @type {ChallengeStatusDto}
     * @memberof ListChallengesItemDto
     */
    'status': ChallengeStatusDto;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ListChallengesItemDto
     */
    'startsAt': EpochMillisTimestamp;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ListChallengesItemDto
     */
    'endsAt'?: EpochMillisTimestamp;
    /**
     * 내가 참여중인지 여부
     * @type {boolean}
     * @memberof ListChallengesItemDto
     */
    'hasJoined': boolean;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ListChallengesItemDto
     */
    'createdAt': EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface ListChallengesRequestDto
 */
export interface ListChallengesRequestDto {
    /**
     * 
     * @type {Array<ChallengeStatusDto>}
     * @memberof ListChallengesRequestDto
     */
    'statuses'?: Array<ChallengeStatusDto>;
    /**
     * 
     * @type {string}
     * @memberof ListChallengesRequestDto
     */
    'nextToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListChallengesRequestDto
     */
    'limit'?: number;
}
/**
 * filter 가 없으면 진행중인, 참여중인 챌린지를 우선적으로 보여준다.
 * @export
 * @interface ListChallengesResponseDto
 */
export interface ListChallengesResponseDto {
    /**
     * 
     * @type {number}
     * @memberof ListChallengesResponseDto
     */
    'totalCount': number;
    /**
     * 
     * @type {string}
     * @memberof ListChallengesResponseDto
     */
    'nextToken'?: string;
    /**
     * 
     * @type {Array<ListChallengesItemDto>}
     * @memberof ListChallengesResponseDto
     */
    'items': Array<ListChallengesItemDto>;
}
/**
 * 
 * @export
 * @interface ListConqueredPlacesRequestDto
 */
export interface ListConqueredPlacesRequestDto {
    /**
     * 페이지 정보. 없으면 첫 페이지 요소들을 내려준다.
     * @type {string}
     * @memberof ListConqueredPlacesRequestDto
     */
    'nextToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListConqueredPlacesRequestDto
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface ListConqueredPlacesResponseDto
 */
export interface ListConqueredPlacesResponseDto {
    /**
     * 정복한 장소의 전체 갯수
     * @type {number}
     * @memberof ListConqueredPlacesResponseDto
     */
    'totalNumberOfItems': number;
    /**
     * 다음 페이지 정보. 없으면 더 이상 요청할 값이 없음을 의미한다.
     * @type {string}
     * @memberof ListConqueredPlacesResponseDto
     */
    'nextToken'?: string;
    /**
     * 
     * @type {Array<PlaceListItem>}
     * @memberof ListConqueredPlacesResponseDto
     */
    'items': Array<PlaceListItem>;
}
/**
 * 
 * @export
 * @interface ListPlaceFavoritesRequestDto
 */
export interface ListPlaceFavoritesRequestDto {
    /**
     * 페이지 정보. 없으면 첫 페이지 요소들을 내려준다.
     * @type {string}
     * @memberof ListPlaceFavoritesRequestDto
     */
    'nextToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof ListPlaceFavoritesRequestDto
     */
    'limit'?: number;
}
/**
 * 
 * @export
 * @interface ListPlaceFavoritesResponseDto
 */
export interface ListPlaceFavoritesResponseDto {
    /**
     * 즐겨찾기한 장소의 전체 개수
     * @type {number}
     * @memberof ListPlaceFavoritesResponseDto
     */
    'totalNumberOfItems': number;
    /**
     * 다음 페이지 정보. 없으면 더 이상 요청할 값이 없음을 의미한다.
     * @type {string}
     * @memberof ListPlaceFavoritesResponseDto
     */
    'nextToken'?: string;
    /**
     * 
     * @type {Array<PlaceListItem>}
     * @memberof ListPlaceFavoritesResponseDto
     */
    'items': Array<PlaceListItem>;
}
/**
 * 
 * @export
 * @interface ListPlacesInBuildingPost200Response
 */
export interface ListPlacesInBuildingPost200Response {
    /**
     * 
     * @type {Array<PlaceListItem>}
     * @memberof ListPlacesInBuildingPost200Response
     */
    'items': Array<PlaceListItem>;
}
/**
 * 
 * @export
 * @interface ListPlacesInBuildingPostRequest
 */
export interface ListPlacesInBuildingPostRequest {
    /**
     * 
     * @type {string}
     * @memberof ListPlacesInBuildingPostRequest
     */
    'buildingId': string;
}
/**
 * 
 * @export
 * @interface ListSearchKeywordsOfPlaceCategoryPost200Response
 */
export interface ListSearchKeywordsOfPlaceCategoryPost200Response {
    /**
     * 
     * @type {Array<SearchKeywordOfPlaceCategoryDto>}
     * @memberof ListSearchKeywordsOfPlaceCategoryPost200Response
     */
    'items': Array<SearchKeywordOfPlaceCategoryDto>;
}
/**
 * 
 * @export
 * @interface ListSearchPlacePresetsResponseDto
 */
export interface ListSearchPlacePresetsResponseDto {
    /**
     * 추천 키워드
     * @type {Array<SearchPlacePresetDto>}
     * @memberof ListSearchPlacePresetsResponseDto
     */
    'keywordPresets': Array<SearchPlacePresetDto>;
}
/**
 * 위치를 위경도로 표현하기 위한 모델.
 * @export
 * @interface Location
 */
export interface Location {
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'lng': number;
    /**
     * 
     * @type {number}
     * @memberof Location
     */
    'lat': number;
}
/**
 * 
 * @export
 * @interface LoginPostRequest
 */
export interface LoginPostRequest {
    /**
     * 
     * @type {string}
     * @memberof LoginPostRequest
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof LoginPostRequest
     */
    'password': string;
}
/**
 * 
 * @export
 * @interface LoginResultDto
 */
export interface LoginResultDto {
    /**
     * 
     * @type {AuthTokensDto}
     * @memberof LoginResultDto
     */
    'authTokens': AuthTokensDto;
    /**
     * 
     * @type {User}
     * @memberof LoginResultDto
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface LoginWithAppleRequestDto
 */
export interface LoginWithAppleRequestDto {
    /**
     * 
     * @type {string}
     * @memberof LoginWithAppleRequestDto
     */
    'identityToken': string;
    /**
     * 
     * @type {string}
     * @memberof LoginWithAppleRequestDto
     */
    'authorizationCode': string;
}
/**
 * 
 * @export
 * @interface LoginWithKakaoPostRequest
 */
export interface LoginWithKakaoPostRequest {
    /**
     * 
     * @type {KakaoTokensDto}
     * @memberof LoginWithKakaoPostRequest
     */
    'kakaoTokens': KakaoTokensDto;
}
/**
 * 점포 정보.
 * @export
 * @interface Place
 */
export interface Place {
    /**
     * 
     * @type {string}
     * @memberof Place
     */
    'id': string;
    /**
     * 점포의 human-readable한 이름.
     * @type {string}
     * @memberof Place
     */
    'name': string;
    /**
     * 점포의 human-readable한 주소.
     * @type {string}
     * @memberof Place
     */
    'address': string;
    /**
     * 
     * @type {Location}
     * @memberof Place
     */
    'location'?: Location;
    /**
     * 
     * @type {PlaceCategoryDto}
     * @memberof Place
     */
    'category'?: PlaceCategoryDto;
    /**
     * 내가 즐겨찾기한 점포인지 여부.
     * @type {boolean}
     * @memberof Place
     */
    'isFavorite'?: boolean;
}
/**
 * 점포의 접근성 정보.
 * @export
 * @interface PlaceAccessibility
 */
export interface PlaceAccessibility {
    /**
     * 
     * @type {string}
     * @memberof PlaceAccessibility
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceAccessibility
     */
    'placeId': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof PlaceAccessibility
     */
    'floors'?: Array<number>;
    /**
     * 1층인지 여부. 240401 출시한 버전부터 이 필드는 사용하지 않고, floors 필드를 사용하도록 한다.
     * @type {boolean}
     * @memberof PlaceAccessibility
     * @deprecated
     */
    'isFirstFloor': boolean;
    /**
     * 다른 층으로 가는 방법이 계단만 있는지 여부
     * @type {boolean}
     * @memberof PlaceAccessibility
     */
    'isStairOnlyOption'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlaceAccessibility
     * @deprecated
     */
    'imageUrls': Array<string>;
    /**
     * 
     * @type {Array<ImageDto>}
     * @memberof PlaceAccessibility
     */
    'images'?: Array<ImageDto>;
    /**
     * 
     * @type {StairInfo}
     * @memberof PlaceAccessibility
     */
    'stairInfo': StairInfo;
    /**
     * 
     * @type {StairHeightLevel}
     * @memberof PlaceAccessibility
     */
    'stairHeightLevel'?: StairHeightLevel;
    /**
     * 
     * @type {boolean}
     * @memberof PlaceAccessibility
     */
    'hasSlope': boolean;
    /**
     * 
     * @type {Array<EntranceDoorType>}
     * @memberof PlaceAccessibility
     */
    'entranceDoorTypes'?: Array<EntranceDoorType>;
    /**
     * 익명으로 등록되었으면 null.
     * @type {string}
     * @memberof PlaceAccessibility
     */
    'registeredUserName'?: string;
    /**
     * 삭제 가능 여부
     * @type {boolean}
     * @memberof PlaceAccessibility
     */
    'isDeletable': boolean;
    /**
     * 
     * @type {ChallengeCrusherGroupDto}
     * @memberof PlaceAccessibility
     */
    'challengeCrusherGroup'?: ChallengeCrusherGroupDto;
    /**
     * 유저가 이 접근성 정보에 \'도움이 돼요\'를 표시했는지 여부.
     * @type {boolean}
     * @memberof PlaceAccessibility
     */
    'isUpvoted'?: boolean;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof PlaceAccessibility
     */
    'createdAt': EpochMillisTimestamp;
}
/**
 * 점포에 대한 의견. 익명으로 달린 댓글이면 user 가 null 이다.
 * @export
 * @interface PlaceAccessibilityComment
 */
export interface PlaceAccessibilityComment {
    /**
     * 
     * @type {string}
     * @memberof PlaceAccessibilityComment
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceAccessibilityComment
     */
    'placeId': string;
    /**
     * 
     * @type {AccessibilityRegistererDto}
     * @memberof PlaceAccessibilityComment
     */
    'user'?: AccessibilityRegistererDto;
    /**
     * 
     * @type {string}
     * @memberof PlaceAccessibilityComment
     */
    'comment': string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof PlaceAccessibilityComment
     */
    'createdAt': EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const PlaceCategoryDto = {
    Restaurant: 'RESTAURANT',
    Cafe: 'CAFE',
    Accomodation: 'ACCOMODATION',
    Market: 'MARKET',
    ConvenienceStore: 'CONVENIENCE_STORE',
    Kindergarten: 'KINDERGARTEN',
    School: 'SCHOOL',
    Academy: 'ACADEMY',
    ParkingLot: 'PARKING_LOT',
    GasStation: 'GAS_STATION',
    SubwayStation: 'SUBWAY_STATION',
    Bank: 'BANK',
    CulturalFacilities: 'CULTURAL_FACILITIES',
    Agency: 'AGENCY',
    PublicOffice: 'PUBLIC_OFFICE',
    Attraction: 'ATTRACTION',
    Hospital: 'HOSPITAL',
    Pharmacy: 'PHARMACY'
} as const;

export type PlaceCategoryDto = typeof PlaceCategoryDto[keyof typeof PlaceCategoryDto];


/**
 * 
 * @export
 * @interface PlaceFavorite
 */
export interface PlaceFavorite {
    /**
     * 
     * @type {string}
     * @memberof PlaceFavorite
     */
    'userId': string;
    /**
     * 
     * @type {string}
     * @memberof PlaceFavorite
     */
    'placeId': string;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof PlaceFavorite
     */
    'createdAt'?: EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface PlaceListItem
 */
export interface PlaceListItem {
    /**
     * 
     * @type {Place}
     * @memberof PlaceListItem
     */
    'place': Place;
    /**
     * 
     * @type {Building}
     * @memberof PlaceListItem
     */
    'building': Building;
    /**
     * 
     * @type {boolean}
     * @memberof PlaceListItem
     */
    'hasBuildingAccessibility': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof PlaceListItem
     */
    'hasPlaceAccessibility': boolean;
    /**
     * 요청에 currentLocation이 올라왔을 경우에만 non-null.
     * @type {number}
     * @memberof PlaceListItem
     */
    'distanceMeters'?: number;
    /**
     * 접근성 정보를 등록할 수 있는지 여부.
     * @type {boolean}
     * @memberof PlaceListItem
     */
    'isAccessibilityRegistrable': boolean;
    /**
     * 
     * @type {CompactAccessibilityInfoDto}
     * @memberof PlaceListItem
     */
    'accessibilityInfo'?: CompactAccessibilityInfoDto;
}
/**
 * 
 * @export
 * @interface PlaceReviewDto
 */
export interface PlaceReviewDto {
    /**
     * 
     * @type {string}
     * @memberof PlaceReviewDto
     */
    'id': string;
    /**
     * 
     * @type {Array<RecommendedMobilityTypeDto>}
     * @memberof PlaceReviewDto
     */
    'recommendedMobilityTypes': Array<RecommendedMobilityTypeDto>;
    /**
     * 
     * @type {SpaciousTypeDto}
     * @memberof PlaceReviewDto
     */
    'spaciousType': SpaciousTypeDto;
    /**
     * 
     * @type {UserMobilityToolDto}
     * @memberof PlaceReviewDto
     */
    'mobilityTool': UserMobilityToolDto;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlaceReviewDto
     */
    'seatTypes': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlaceReviewDto
     */
    'orderMethods': Array<string>;
    /**
     * 
     * @type {Array<string>}
     * @memberof PlaceReviewDto
     */
    'features'?: Array<string>;
    /**
     * 
     * @type {string}
     * @memberof PlaceReviewDto
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<ImageDto>}
     * @memberof PlaceReviewDto
     */
    'images'?: Array<ImageDto>;
    /**
     * 
     * @type {AccessibilityRegistererDto}
     * @memberof PlaceReviewDto
     */
    'user': AccessibilityRegistererDto;
    /**
     * 
     * @type {boolean}
     * @memberof PlaceReviewDto
     */
    'isDeletable': boolean;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof PlaceReviewDto
     */
    'createdAt': EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const RecommendedMobilityTypeDto = {
    ManualWheelchair: 'MANUAL_WHEELCHAIR',
    ElectricWheelchair: 'ELECTRIC_WHEELCHAIR',
    Elderly: 'ELDERLY',
    Stroller: 'STROLLER',
    NotSure: 'NOT_SURE',
    None: 'NONE'
} as const;

export type RecommendedMobilityTypeDto = typeof RecommendedMobilityTypeDto[keyof typeof RecommendedMobilityTypeDto];


/**
 * 
 * @export
 * @interface RecordCrusherClubActivityRequestDto
 */
export interface RecordCrusherClubActivityRequestDto {
    /**
     * 
     * @type {CrusherClubQuestTypeDto}
     * @memberof RecordCrusherClubActivityRequestDto
     */
    'questType': CrusherClubQuestTypeDto;
}
/**
 * 
 * @export
 * @interface RecordCrusherClubActivityResponseDto
 */
export interface RecordCrusherClubActivityResponseDto {
    /**
     * 
     * @type {CurrentCrusherActivityDto}
     * @memberof RecordCrusherClubActivityResponseDto
     */
    'currentCrusherActivity'?: CurrentCrusherActivityDto;
}
/**
 * 
 * @export
 * @interface RectangleSearchRegionDto
 */
export interface RectangleSearchRegionDto {
    /**
     * 
     * @type {Location}
     * @memberof RectangleSearchRegionDto
     */
    'leftTopLocation': Location;
    /**
     * 
     * @type {Location}
     * @memberof RectangleSearchRegionDto
     */
    'rightBottomLocation': Location;
}
/**
 * 
 * @export
 * @interface RegisterBuildingAccessibilityCommentPost200Response
 */
export interface RegisterBuildingAccessibilityCommentPost200Response {
    /**
     * 
     * @type {BuildingAccessibilityComment}
     * @memberof RegisterBuildingAccessibilityCommentPost200Response
     */
    'buildingAccessibilityComment': BuildingAccessibilityComment;
}
/**
 * 
 * @export
 * @interface RegisterBuildingAccessibilityCommentPostRequest
 */
export interface RegisterBuildingAccessibilityCommentPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterBuildingAccessibilityCommentPostRequest
     */
    'buildingId': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterBuildingAccessibilityCommentPostRequest
     */
    'comment': string;
}
/**
 * 각 건물에 대해 1번만 등록될 수 있다.
 * @export
 * @interface RegisterBuildingAccessibilityRequestDto
 */
export interface RegisterBuildingAccessibilityRequestDto {
    /**
     * 
     * @type {string}
     * @memberof RegisterBuildingAccessibilityRequestDto
     */
    'buildingId': string;
    /**
     * 
     * @type {StairInfo}
     * @memberof RegisterBuildingAccessibilityRequestDto
     */
    'entranceStairInfo': StairInfo;
    /**
     * 
     * @type {StairHeightLevel}
     * @memberof RegisterBuildingAccessibilityRequestDto
     */
    'entranceStairHeightLevel'?: StairHeightLevel;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegisterBuildingAccessibilityRequestDto
     */
    'entranceImageUrls': Array<string>;
    /**
     * 
     * @type {Array<EntranceDoorType>}
     * @memberof RegisterBuildingAccessibilityRequestDto
     */
    'entranceDoorTypes'?: Array<EntranceDoorType>;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterBuildingAccessibilityRequestDto
     */
    'hasSlope': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterBuildingAccessibilityRequestDto
     */
    'hasElevator': boolean;
    /**
     * 
     * @type {StairInfo}
     * @memberof RegisterBuildingAccessibilityRequestDto
     */
    'elevatorStairInfo': StairInfo;
    /**
     * 
     * @type {StairHeightLevel}
     * @memberof RegisterBuildingAccessibilityRequestDto
     */
    'elevatorStairHeightLevel'?: StairHeightLevel;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegisterBuildingAccessibilityRequestDto
     */
    'elevatorImageUrls': Array<string>;
    /**
     * 
     * @type {string}
     * @memberof RegisterBuildingAccessibilityRequestDto
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface RegisterBuildingAccessibilityResponseDto
 */
export interface RegisterBuildingAccessibilityResponseDto {
    /**
     * 이 정보 등록으로 인해 기여한 챌린지 목록
     * @type {Array<ContributedChallengeInfoDto>}
     * @memberof RegisterBuildingAccessibilityResponseDto
     */
    'contributedChallengeInfos'?: Array<ContributedChallengeInfoDto>;
}
/**
 * 
 * @export
 * @interface RegisterPlaceAccessibilityCommentPost200Response
 */
export interface RegisterPlaceAccessibilityCommentPost200Response {
    /**
     * 
     * @type {PlaceAccessibilityComment}
     * @memberof RegisterPlaceAccessibilityCommentPost200Response
     */
    'placeAccessibilityComment': PlaceAccessibilityComment;
}
/**
 * 
 * @export
 * @interface RegisterPlaceAccessibilityCommentPostRequest
 */
export interface RegisterPlaceAccessibilityCommentPostRequest {
    /**
     * 
     * @type {string}
     * @memberof RegisterPlaceAccessibilityCommentPostRequest
     */
    'placeId': string;
    /**
     * 
     * @type {string}
     * @memberof RegisterPlaceAccessibilityCommentPostRequest
     */
    'comment': string;
}
/**
 * 
 * @export
 * @interface RegisterPlaceAccessibilityRequestDto
 */
export interface RegisterPlaceAccessibilityRequestDto {
    /**
     * 
     * @type {string}
     * @memberof RegisterPlaceAccessibilityRequestDto
     */
    'placeId': string;
    /**
     * 
     * @type {Array<number>}
     * @memberof RegisterPlaceAccessibilityRequestDto
     */
    'floors'?: Array<number>;
    /**
     * 다른 층으로 가는 방법이 계단만 있는지 여부
     * @type {boolean}
     * @memberof RegisterPlaceAccessibilityRequestDto
     */
    'isStairOnlyOption'?: boolean;
    /**
     * 1층인지 여부. 240401 출시한 버전부터 이 필드는 사용하지 않고, floors 필드를 사용하도록 한다.
     * @type {boolean}
     * @memberof RegisterPlaceAccessibilityRequestDto
     * @deprecated
     */
    'isFirstFloor'?: boolean;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegisterPlaceAccessibilityRequestDto
     */
    'imageUrls': Array<string>;
    /**
     * 
     * @type {StairInfo}
     * @memberof RegisterPlaceAccessibilityRequestDto
     */
    'stairInfo': StairInfo;
    /**
     * 
     * @type {StairHeightLevel}
     * @memberof RegisterPlaceAccessibilityRequestDto
     */
    'stairHeightLevel'?: StairHeightLevel;
    /**
     * 
     * @type {boolean}
     * @memberof RegisterPlaceAccessibilityRequestDto
     */
    'hasSlope': boolean;
    /**
     * 
     * @type {Array<EntranceDoorType>}
     * @memberof RegisterPlaceAccessibilityRequestDto
     */
    'entranceDoorTypes'?: Array<EntranceDoorType>;
    /**
     * 
     * @type {string}
     * @memberof RegisterPlaceAccessibilityRequestDto
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface RegisterPlaceAccessibilityResponseDto
 */
export interface RegisterPlaceAccessibilityResponseDto {
    /**
     * 
     * @type {AccessibilityInfoDto}
     * @memberof RegisterPlaceAccessibilityResponseDto
     */
    'accessibilityInfo': AccessibilityInfoDto;
    /**
     * \'n번째 정복자\'를 표시해주기 위한 값.
     * @type {number}
     * @memberof RegisterPlaceAccessibilityResponseDto
     */
    'registeredUserOrder': number;
    /**
     * 이 정보 등록으로 인해 기여한 챌린지 목록
     * @type {Array<ContributedChallengeInfoDto>}
     * @memberof RegisterPlaceAccessibilityResponseDto
     */
    'contributedChallengeInfos'?: Array<ContributedChallengeInfoDto>;
}
/**
 * 
 * @export
 * @interface RegisterPlaceReviewRequestDto
 */
export interface RegisterPlaceReviewRequestDto {
    /**
     * 
     * @type {string}
     * @memberof RegisterPlaceReviewRequestDto
     */
    'placeId': string;
    /**
     * 누구에게 추천하시나요?
     * @type {Array<RecommendedMobilityTypeDto>}
     * @memberof RegisterPlaceReviewRequestDto
     */
    'recommendedMobilityTypes': Array<RecommendedMobilityTypeDto>;
    /**
     * 
     * @type {SpaciousTypeDto}
     * @memberof RegisterPlaceReviewRequestDto
     */
    'spaciousType': SpaciousTypeDto;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegisterPlaceReviewRequestDto
     */
    'imageUrls'?: Array<string>;
    /**
     * 장소 이용 경험
     * @type {string}
     * @memberof RegisterPlaceReviewRequestDto
     */
    'comment'?: string;
    /**
     * 
     * @type {UserMobilityToolDto}
     * @memberof RegisterPlaceReviewRequestDto
     */
    'mobilityTool': UserMobilityToolDto;
    /**
     * 좌석 구성
     * @type {Array<string>}
     * @memberof RegisterPlaceReviewRequestDto
     */
    'seatTypes': Array<string>;
    /**
     * 매장 내 주문 방법
     * @type {Array<string>}
     * @memberof RegisterPlaceReviewRequestDto
     */
    'orderMethods': Array<string>;
    /**
     * 공간 특이사항
     * @type {Array<string>}
     * @memberof RegisterPlaceReviewRequestDto
     */
    'features'?: Array<string>;
}
/**
 * 
 * @export
 * @interface RegisterPlaceReviewResponseDto
 */
export interface RegisterPlaceReviewResponseDto {
    /**
     * 
     * @type {PlaceReviewDto}
     * @memberof RegisterPlaceReviewResponseDto
     */
    'placeReview': PlaceReviewDto;
    /**
     * 이 리뷰 등록으로 인해 기여한 챌린지 목록
     * @type {Array<ContributedChallengeInfoDto>}
     * @memberof RegisterPlaceReviewResponseDto
     */
    'contributedChallengeInfos'?: Array<ContributedChallengeInfoDto>;
}
/**
 * 
 * @export
 * @interface RegisterToiletReviewPost200Response
 */
export interface RegisterToiletReviewPost200Response {
    /**
     * 
     * @type {ToiletReviewDto}
     * @memberof RegisterToiletReviewPost200Response
     */
    'toiletReview'?: ToiletReviewDto;
}
/**
 * 
 * @export
 * @interface RegisterToiletReviewRequestDto
 */
export interface RegisterToiletReviewRequestDto {
    /**
     * 
     * @type {string}
     * @memberof RegisterToiletReviewRequestDto
     */
    'placeId': string;
    /**
     * 
     * @type {UserMobilityToolDto}
     * @memberof RegisterToiletReviewRequestDto
     */
    'mobilityTool': UserMobilityToolDto;
    /**
     * 
     * @type {ToiletLocationTypeDto}
     * @memberof RegisterToiletReviewRequestDto
     */
    'toiletLocationType': ToiletLocationTypeDto;
    /**
     * 몇층에 있는 장소인가요?
     * @type {number}
     * @memberof RegisterToiletReviewRequestDto
     */
    'floor'?: number;
    /**
     * 
     * @type {Array<EntranceDoorType>}
     * @memberof RegisterToiletReviewRequestDto
     */
    'entranceDoorTypes'?: Array<EntranceDoorType>;
    /**
     * 
     * @type {Array<string>}
     * @memberof RegisterToiletReviewRequestDto
     */
    'imageUrls'?: Array<string>;
    /**
     * 화장실에 대해 자세히 알려주세요
     * @type {string}
     * @memberof RegisterToiletReviewRequestDto
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface ReportAccessibilityPostRequest
 */
export interface ReportAccessibilityPostRequest {
    /**
     * 신고할 장소의 아이디
     * @type {string}
     * @memberof ReportAccessibilityPostRequest
     * @deprecated
     */
    'placeId': string;
    /**
     * 
     * @type {ReportTargetTypeDto}
     * @memberof ReportAccessibilityPostRequest
     */
    'targetType'?: ReportTargetTypeDto;
    /**
     * 신고하고자 하는 정보의 id
     * @type {string}
     * @memberof ReportAccessibilityPostRequest
     */
    'id'?: string;
    /**
     * 
     * @type {AccessibilityReportReason}
     * @memberof ReportAccessibilityPostRequest
     */
    'reason': AccessibilityReportReason;
    /**
     * 신고 상세 내용
     * @type {string}
     * @memberof ReportAccessibilityPostRequest
     */
    'detail'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ReportTargetTypeDto = {
    PlaceAccessibility: 'PLACE_ACCESSIBILITY',
    BuildingAccessibility: 'BUILDING_ACCESSIBILITY',
    PlaceReview: 'PLACE_REVIEW',
    ToiletReview: 'TOILET_REVIEW'
} as const;

export type ReportTargetTypeDto = typeof ReportTargetTypeDto[keyof typeof ReportTargetTypeDto];


/**
 * 
 * @export
 * @interface SearchExternalAccessibilitiesPost200Response
 */
export interface SearchExternalAccessibilitiesPost200Response {
    /**
     * 
     * @type {Array<ExternalAccessibility>}
     * @memberof SearchExternalAccessibilitiesPost200Response
     */
    'items'?: Array<ExternalAccessibility>;
}
/**
 * 
 * @export
 * @interface SearchExternalAccessibilitiesPostRequest
 */
export interface SearchExternalAccessibilitiesPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SearchExternalAccessibilitiesPostRequest
     */
    'searchText'?: string;
    /**
     * 
     * @type {Location}
     * @memberof SearchExternalAccessibilitiesPostRequest
     */
    'currentLocation'?: Location;
    /**
     * 
     * @type {number}
     * @memberof SearchExternalAccessibilitiesPostRequest
     */
    'distanceMetersLimit': number;
    /**
     * 조회하고 싶은 접근성 정보 카테고리. 현재 화장실 (TOILET) 만 있음.
     * @type {Array<string>}
     * @memberof SearchExternalAccessibilitiesPostRequest
     */
    'categories'?: Array<string>;
}
/**
 * 
 * @export
 * @interface SearchKeywordOfPlaceCategoryDto
 */
export interface SearchKeywordOfPlaceCategoryDto {
    /**
     * 
     * @type {PlaceCategoryDto}
     * @memberof SearchKeywordOfPlaceCategoryDto
     */
    'category': PlaceCategoryDto;
    /**
     * 검색창에 들어가는 문자열. ex) 음식점, 병원, 카페
     * @type {string}
     * @memberof SearchKeywordOfPlaceCategoryDto
     */
    'keyword': string;
}
/**
 * 
 * @export
 * @interface SearchPlaceFilterDto
 */
export interface SearchPlaceFilterDto {
    /**
     * 접근성 점수의 최대값. 이 값 이하의 점수를 가진 장소만 반환한다. null이면 필터링하지 않는다.
     * @type {number}
     * @memberof SearchPlaceFilterDto
     */
    'maxAccessibilityScore'?: number;
    /**
     * 경사로가 있는/없는 장소만 반환한다. null이면 필터링하지 않는다.
     * @type {boolean}
     * @memberof SearchPlaceFilterDto
     */
    'hasSlope'?: boolean;
    /**
     * 접근성 정보가 등록된/등록되지 않은 장소만 반환한다. null이면 필터링하지 않는다.
     * @type {boolean}
     * @memberof SearchPlaceFilterDto
     */
    'isRegistered'?: boolean;
}
/**
 * 
 * @export
 * @interface SearchPlacePresetDto
 */
export interface SearchPlacePresetDto {
    /**
     * 
     * @type {string}
     * @memberof SearchPlacePresetDto
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SearchPlacePresetDto
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof SearchPlacePresetDto
     */
    'searchText': string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const SearchPlaceSortDto = {
    Accuracy: 'ACCURACY',
    Distance: 'DISTANCE',
    AccessibilityScore: 'ACCESSIBILITY_SCORE'
} as const;

export type SearchPlaceSortDto = typeof SearchPlaceSortDto[keyof typeof SearchPlaceSortDto];


/**
 * 
 * @export
 * @interface SearchPlacesRequestDto
 */
export interface SearchPlacesRequestDto {
    /**
     * 
     * @type {string}
     * @memberof SearchPlacesRequestDto
     */
    'searchText': string;
    /**
     * 
     * @type {Location}
     * @memberof SearchPlacesRequestDto
     */
    'currentLocation'?: Location;
    /**
     * 
     * @type {number}
     * @memberof SearchPlacesRequestDto
     */
    'distanceMetersLimit'?: number;
    /**
     * 
     * @type {CircleSearchRegionDto}
     * @memberof SearchPlacesRequestDto
     */
    'circleRegion'?: CircleSearchRegionDto;
    /**
     * 
     * @type {RectangleSearchRegionDto}
     * @memberof SearchPlacesRequestDto
     */
    'rectangleRegion'?: RectangleSearchRegionDto;
    /**
     * 
     * @type {string}
     * @memberof SearchPlacesRequestDto
     */
    'siGunGuId'?: string;
    /**
     * 
     * @type {string}
     * @memberof SearchPlacesRequestDto
     */
    'eupMyeonDongId'?: string;
    /**
     * 
     * @type {SearchPlaceSortDto}
     * @memberof SearchPlacesRequestDto
     */
    'sort'?: SearchPlaceSortDto;
    /**
     * 
     * @type {SearchPlaceFilterDto}
     * @memberof SearchPlacesRequestDto
     */
    'filters'?: SearchPlaceFilterDto;
}
/**
 * 
 * @export
 * @interface SearchPlacesResponseDto
 */
export interface SearchPlacesResponseDto {
    /**
     * 
     * @type {Array<PlaceListItem>}
     * @memberof SearchPlacesResponseDto
     */
    'items': Array<PlaceListItem>;
}
/**
 * 시군구를 표현하기 위한 모델.
 * @export
 * @interface SiGunGu
 */
export interface SiGunGu {
    /**
     * 
     * @type {string}
     * @memberof SiGunGu
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof SiGunGu
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface SignUpPostRequest
 */
export interface SignUpPostRequest {
    /**
     * 
     * @type {string}
     * @memberof SignUpPostRequest
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpPostRequest
     */
    'password': string;
    /**
     * 
     * @type {string}
     * @memberof SignUpPostRequest
     */
    'instagram_id'?: string;
}
/**
 * 내부 공간이 여유롭나요?
 * @export
 * @enum {string}
 */

export const SpaciousTypeDto = {
    Wide: 'WIDE',
    Enough: 'ENOUGH',
    Limited: 'LIMITED',
    Tight: 'TIGHT'
} as const;

export type SpaciousTypeDto = typeof SpaciousTypeDto[keyof typeof SpaciousTypeDto];


/**
 * 
 * @export
 * @enum {string}
 */

export const StairHeightLevel = {
    HalfThumb: 'HALF_THUMB',
    Thumb: 'THUMB',
    OverThumb: 'OVER_THUMB'
} as const;

export type StairHeightLevel = typeof StairHeightLevel[keyof typeof StairHeightLevel];


/**
 * 
 * @export
 * @enum {string}
 */

export const StairInfo = {
    Undefined: 'UNDEFINED',
    None: 'NONE',
    One: 'ONE',
    TwoToFive: 'TWO_TO_FIVE',
    OverSix: 'OVER_SIX'
} as const;

export type StairInfo = typeof StairInfo[keyof typeof StairInfo];


/**
 * 
 * @export
 * @interface ToiletAccessibilityDetails
 */
export interface ToiletAccessibilityDetails {
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'image_url'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'accessDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'availableDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'entranceDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'stallWidth'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'stallDepth'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'doorDesc'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'doorSideRoom'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'washStandBelowRoom'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'washStandHandle'?: string;
    /**
     * 
     * @type {string}
     * @memberof ToiletAccessibilityDetails
     */
    'extraDesc'?: string;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const ToiletLocationTypeDto = {
    Place: 'PLACE',
    Building: 'BUILDING',
    None: 'NONE',
    Etc: 'ETC'
} as const;

export type ToiletLocationTypeDto = typeof ToiletLocationTypeDto[keyof typeof ToiletLocationTypeDto];


/**
 * 
 * @export
 * @interface ToiletReviewDto
 */
export interface ToiletReviewDto {
    /**
     * 
     * @type {string}
     * @memberof ToiletReviewDto
     */
    'id': string;
    /**
     * 
     * @type {UserMobilityToolDto}
     * @memberof ToiletReviewDto
     */
    'mobilityTool': UserMobilityToolDto;
    /**
     * 
     * @type {ToiletLocationTypeDto}
     * @memberof ToiletReviewDto
     */
    'toiletLocationType': ToiletLocationTypeDto;
    /**
     * 
     * @type {number}
     * @memberof ToiletReviewDto
     */
    'floor'?: number;
    /**
     * 
     * @type {Array<EntranceDoorType>}
     * @memberof ToiletReviewDto
     */
    'entranceDoorTypes'?: Array<EntranceDoorType>;
    /**
     * 
     * @type {string}
     * @memberof ToiletReviewDto
     */
    'comment'?: string;
    /**
     * 
     * @type {Array<ImageDto>}
     * @memberof ToiletReviewDto
     */
    'images'?: Array<ImageDto>;
    /**
     * 
     * @type {AccessibilityRegistererDto}
     * @memberof ToiletReviewDto
     */
    'user': AccessibilityRegistererDto;
    /**
     * 
     * @type {boolean}
     * @memberof ToiletReviewDto
     */
    'isDeletable': boolean;
    /**
     * 
     * @type {EpochMillisTimestamp}
     * @memberof ToiletReviewDto
     */
    'createdAt': EpochMillisTimestamp;
}
/**
 * 
 * @export
 * @interface UpdatePushTokenPostRequest
 */
export interface UpdatePushTokenPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdatePushTokenPostRequest
     */
    'pushToken': string;
}
/**
 * 
 * @export
 * @interface UpdateUserInfoPost200Response
 */
export interface UpdateUserInfoPost200Response {
    /**
     * 
     * @type {User}
     * @memberof UpdateUserInfoPost200Response
     */
    'user': User;
}
/**
 * 
 * @export
 * @interface UpdateUserInfoPostRequest
 */
export interface UpdateUserInfoPostRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateUserInfoPostRequest
     */
    'nickname': string;
    /**
     * 변경되지 않았으면 기존 값을 그대로 올려준다.
     * @type {string}
     * @memberof UpdateUserInfoPostRequest
     */
    'instagramId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateUserInfoPostRequest
     */
    'email': string;
    /**
     * 
     * @type {number}
     * @memberof UpdateUserInfoPostRequest
     */
    'birthYear'?: number;
    /**
     * 
     * @type {Array<UserMobilityToolDto>}
     * @memberof UpdateUserInfoPostRequest
     */
    'mobilityTools': Array<UserMobilityToolDto>;
    /**
     * 
     * @type {boolean}
     * @memberof UpdateUserInfoPostRequest
     */
    'isNewsLetterSubscriptionAgreed'?: boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UpvoteTargetTypeDto = {
    PlaceAccessibility: 'PLACE_ACCESSIBILITY',
    BuildingAccessibility: 'BUILDING_ACCESSIBILITY'
} as const;

export type UpvoteTargetTypeDto = typeof UpvoteTargetTypeDto[keyof typeof UpvoteTargetTypeDto];


/**
 * 유저 정보.
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'nickname': string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'instagramId'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {number}
     * @memberof User
     */
    'birthYear'?: number;
    /**
     * 
     * @type {Array<UserMobilityToolDto>}
     * @memberof User
     */
    'mobilityTools': Array<UserMobilityToolDto>;
    /**
     * 뉴스레터 구독 동의 여부
     * @type {boolean}
     * @memberof User
     */
    'isNewsLetterSubscriptionAgreed': boolean;
}
/**
 * 
 * @export
 * @enum {string}
 */

export const UserMobilityToolDto = {
    ManualWheelchair: 'MANUAL_WHEELCHAIR',
    ElectricWheelchair: 'ELECTRIC_WHEELCHAIR',
    ManualAndElectricWheelchair: 'MANUAL_AND_ELECTRIC_WHEELCHAIR',
    Stroller: 'STROLLER',
    ProstheticFoot: 'PROSTHETIC_FOOT',
    WalkingAssistanceDevice: 'WALKING_ASSISTANCE_DEVICE',
    Cluch: 'CLUCH',
    None: 'NONE',
    FriendOfToolUser: 'FRIEND_OF_TOOL_USER'
} as const;

export type UserMobilityToolDto = typeof UserMobilityToolDto[keyof typeof UserMobilityToolDto];


/**
 * 
 * @export
 * @interface ValidateUserProfilePost200Response
 */
export interface ValidateUserProfilePost200Response {
    /**
     * 닉네임이 유효하지 않은 경우 에러 메시지, 유효하거나 null인 경우 null
     * @type {string}
     * @memberof ValidateUserProfilePost200Response
     */
    'nicknameErrorMessage'?: string;
    /**
     * 이메일이 유효하지 않은 경우 에러 메시지, 유효하거나 null인 경우 null
     * @type {string}
     * @memberof ValidateUserProfilePost200Response
     */
    'emailErrorMessage'?: string;
}
/**
 * 
 * @export
 * @interface ValidateUserProfilePostRequest
 */
export interface ValidateUserProfilePostRequest {
    /**
     * 유효성을 검사할 닉네임. null인 경우 유효한 것으로 간주
     * @type {string}
     * @memberof ValidateUserProfilePostRequest
     */
    'nickname'?: string;
    /**
     * 유효성을 검사할 이메일. null인 경우 유효한 것으로 간주
     * @type {string}
     * @memberof ValidateUserProfilePostRequest
     */
    'email'?: string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary 건물에 대해 \'이 정보가 도움이 돼요\'를 취소한다.
         * @param {CancelBuildingAccessibilityUpvoteRequestDto} cancelBuildingAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        cancelBuildingAccessibilityUpvotePost: async (cancelBuildingAccessibilityUpvoteRequestDto: CancelBuildingAccessibilityUpvoteRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelBuildingAccessibilityUpvoteRequestDto' is not null or undefined
            assertParamExists('cancelBuildingAccessibilityUpvotePost', 'cancelBuildingAccessibilityUpvoteRequestDto', cancelBuildingAccessibilityUpvoteRequestDto)
            const localVarPath = `/cancelBuildingAccessibilityUpvote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelBuildingAccessibilityUpvoteRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 장소에 대해 \'이 정보가 도움이 돼요\'를 취소한다.
         * @param {CancelPlaceAccessibilityUpvoteRequestDto} cancelPlaceAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        cancelPlaceAccessibilityUpvotePost: async (cancelPlaceAccessibilityUpvoteRequestDto: CancelPlaceAccessibilityUpvoteRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelPlaceAccessibilityUpvoteRequestDto' is not null or undefined
            assertParamExists('cancelPlaceAccessibilityUpvotePost', 'cancelPlaceAccessibilityUpvoteRequestDto', cancelPlaceAccessibilityUpvoteRequestDto)
            const localVarPath = `/cancelPlaceAccessibilityUpvote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelPlaceAccessibilityUpvoteRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary \'도움이 돼요\'를 취소한다.
         * @param {CancelUpvoteRequestDto} cancelUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelUpvotePost: async (cancelUpvoteRequestDto: CancelUpvoteRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'cancelUpvoteRequestDto' is not null or undefined
            assertParamExists('cancelUpvotePost', 'cancelUpvoteRequestDto', cancelUpvoteRequestDto)
            const localVarPath = `/cancelUpvote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(cancelUpvoteRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 비회원 계정을 생성한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnonymousUserPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/createAnonymousUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 장소를 즐겨찾기에 추가한다.
         * @param {CreatePlaceFavoriteRequestDto} createPlaceFavoriteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaceFavoritePost: async (createPlaceFavoriteRequestDto: CreatePlaceFavoriteRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'createPlaceFavoriteRequestDto' is not null or undefined
            assertParamExists('createPlaceFavoritePost', 'createPlaceFavoriteRequestDto', createPlaceFavoriteRequestDto)
            const localVarPath = `/createPlaceFavorite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(createPlaceFavoriteRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 등록한 건물의 접근성 정보를 삭제한다. 
         * @param {DeleteBuildingAccessibilityPostRequest} deleteBuildingAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildingAccessibilityPost: async (deleteBuildingAccessibilityPostRequest: DeleteBuildingAccessibilityPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteBuildingAccessibilityPostRequest' is not null or undefined
            assertParamExists('deleteBuildingAccessibilityPost', 'deleteBuildingAccessibilityPostRequest', deleteBuildingAccessibilityPostRequest)
            const localVarPath = `/deleteBuildingAccessibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteBuildingAccessibilityPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 등록한 장소의 접근성 정보를 삭제한다. 
         * @param {DeletePlaceAccessibilityPostRequest} deletePlaceAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceAccessibilityPost: async (deletePlaceAccessibilityPostRequest: DeletePlaceAccessibilityPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deletePlaceAccessibilityPostRequest' is not null or undefined
            assertParamExists('deletePlaceAccessibilityPost', 'deletePlaceAccessibilityPostRequest', deletePlaceAccessibilityPostRequest)
            const localVarPath = `/deletePlaceAccessibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePlaceAccessibilityPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 장소를 즐겨찾기에서 삭제한다.
         * @param {DeletePlaceFavoriteRequestDto} deletePlaceFavoriteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceFavoritePost: async (deletePlaceFavoriteRequestDto: DeletePlaceFavoriteRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deletePlaceFavoriteRequestDto' is not null or undefined
            assertParamExists('deletePlaceFavoritePost', 'deletePlaceFavoriteRequestDto', deletePlaceFavoriteRequestDto)
            const localVarPath = `/deletePlaceFavorite`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePlaceFavoriteRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 등록한 장소 리뷰를 삭제한다.
         * @param {DeletePlaceReviewPostRequest} deletePlaceReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceReviewPost: async (deletePlaceReviewPostRequest: DeletePlaceReviewPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deletePlaceReviewPostRequest' is not null or undefined
            assertParamExists('deletePlaceReviewPost', 'deletePlaceReviewPostRequest', deletePlaceReviewPostRequest)
            const localVarPath = `/deletePlaceReview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deletePlaceReviewPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 등록한 화장실 리뷰를 삭제한다.
         * @param {DeleteToiletReviewPostRequest} deleteToiletReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToiletReviewPost: async (deleteToiletReviewPostRequest: DeleteToiletReviewPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'deleteToiletReviewPostRequest' is not null or undefined
            assertParamExists('deleteToiletReviewPost', 'deleteToiletReviewPostRequest', deleteToiletReviewPostRequest)
            const localVarPath = `/deleteToiletReview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(deleteToiletReviewPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 계정을 삭제한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/deleteUser`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 유저 접근성 정보 정복 활동을 조회한다
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessibilityActivityReportPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getAccessibilityActivityReport`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 현재 탑 랭커들을 조회한다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessibilityLeaderboardPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('getAccessibilityLeaderboardPost', 'body', body)
            const localVarPath = `/getAccessibilityLeaderboard`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 건물 & 점포의 접근성 정보를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessibilityPost: async (getAccessibilityPostRequest: GetAccessibilityPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAccessibilityPostRequest' is not null or undefined
            assertParamExists('getAccessibilityPost', 'getAccessibilityPostRequest', getAccessibilityPostRequest)
            const localVarPath = `/getAccessibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAccessibilityPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 내 현재 랭크를 조회한다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessibilityRankPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('getAccessibilityRankPost', 'body', body)
            const localVarPath = `/getAccessibilityRank`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 챌린지 리스트에서 공개된 챌린지를 선택해서 챌린지를 조회한다.
         * @param {GetChallengeRequestDto} getChallengeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallengePost: async (getChallengeRequestDto: GetChallengeRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getChallengeRequestDto' is not null or undefined
            assertParamExists('getChallengePost', 'getChallengeRequestDto', getChallengeRequestDto)
            const localVarPath = `/getChallenge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getChallengeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 공개되지 않은 챌린지를 초대코드를 통해 챌린지를 조회한다.
         * @param {GetChallengeWithInvitationCodeRequestDto} getChallengeWithInvitationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallengeWithInvitationCodePost: async (getChallengeWithInvitationCodeRequestDto: GetChallengeWithInvitationCodeRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getChallengeWithInvitationCodeRequestDto' is not null or undefined
            assertParamExists('getChallengeWithInvitationCodePost', 'getChallengeWithInvitationCodeRequestDto', getChallengeWithInvitationCodeRequestDto)
            const localVarPath = `/getChallengeWithInvitationCode`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getChallengeWithInvitationCodeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 앱 버전에 따라 업데이트 상태를 알려준다
         * @param {GetClientVersionStatusRequestDto} getClientVersionStatusRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientVersionStatusPost: async (getClientVersionStatusRequestDto: GetClientVersionStatusRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getClientVersionStatusRequestDto' is not null or undefined
            assertParamExists('getClientVersionStatusPost', 'getClientVersionStatusRequestDto', getClientVersionStatusRequestDto)
            const localVarPath = `/getClientVersionStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getClientVersionStatusRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 다음 랭크로 올라가기 위한 점수를 조회한다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountForNextRankPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('getCountForNextRankPost', 'body', body)
            const localVarPath = `/getCountForNextRank`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 현재 진행 중인 크러셔 활동 내역을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentCrusherActivityPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getCurrentCrusherActivity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 공공 접근성 정보를 확인한다.
         * @param {GetExternalAccessibilityPostRequest} getExternalAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalAccessibilityPost: async (getExternalAccessibilityPostRequest: GetExternalAccessibilityPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getExternalAccessibilityPostRequest' is not null or undefined
            assertParamExists('getExternalAccessibilityPost', 'getExternalAccessibilityPostRequest', getExternalAccessibilityPostRequest)
            const localVarPath = `/getExternalAccessibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getExternalAccessibilityPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 홈에서 보여줄 배너 정보 목록을 가져온다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeBanners: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getHomeBanners`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 점포 정보 등록 등의 상황에서 이미지를 업로드하기 위한 URL을 받아 온다.
         * @param {GetImageUploadUrlsPostRequest} getImageUploadUrlsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageUploadUrlsPost: async (getImageUploadUrlsPostRequest: GetImageUploadUrlsPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getImageUploadUrlsPostRequest' is not null or undefined
            assertParamExists('getImageUploadUrlsPost', 'getImageUploadUrlsPostRequest', getImageUploadUrlsPostRequest)
            const localVarPath = `/getImageUploadUrls`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getImageUploadUrlsPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 주변 정복 상태를 조회한다.
         * @param {GetNearbyAccessibilityStatusPostRequest} getNearbyAccessibilityStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNearbyAccessibilityStatusPost: async (getNearbyAccessibilityStatusPostRequest: GetNearbyAccessibilityStatusPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getNearbyAccessibilityStatusPostRequest' is not null or undefined
            assertParamExists('getNearbyAccessibilityStatusPost', 'getNearbyAccessibilityStatusPostRequest', getNearbyAccessibilityStatusPostRequest)
            const localVarPath = `/getNearbyAccessibilityStatus`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getNearbyAccessibilityStatusPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 건물 & 점포 정보를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaceWithBuildingPost: async (getAccessibilityPostRequest: GetAccessibilityPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAccessibilityPostRequest' is not null or undefined
            assertParamExists('getPlaceWithBuildingPost', 'getAccessibilityPostRequest', getAccessibilityPostRequest)
            const localVarPath = `/getPlaceWithBuilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAccessibilityPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 유저 정보를 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/getUserInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 건물에 대해 \'이 정보가 도움이 돼요\'를 준다.
         * @param {GiveBuildingAccessibilityUpvoteRequestDto} giveBuildingAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        giveBuildingAccessibilityUpvotePost: async (giveBuildingAccessibilityUpvoteRequestDto: GiveBuildingAccessibilityUpvoteRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giveBuildingAccessibilityUpvoteRequestDto' is not null or undefined
            assertParamExists('giveBuildingAccessibilityUpvotePost', 'giveBuildingAccessibilityUpvoteRequestDto', giveBuildingAccessibilityUpvoteRequestDto)
            const localVarPath = `/giveBuildingAccessibilityUpvote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giveBuildingAccessibilityUpvoteRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 장소에 대해 \'이 정보가 도움이 돼요\'를 준다.
         * @param {GivePlaceAccessibilityUpvoteRequestDto} givePlaceAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        givePlaceAccessibilityUpvotePost: async (givePlaceAccessibilityUpvoteRequestDto: GivePlaceAccessibilityUpvoteRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'givePlaceAccessibilityUpvoteRequestDto' is not null or undefined
            assertParamExists('givePlaceAccessibilityUpvotePost', 'givePlaceAccessibilityUpvoteRequestDto', givePlaceAccessibilityUpvoteRequestDto)
            const localVarPath = `/givePlaceAccessibilityUpvote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(givePlaceAccessibilityUpvoteRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary \'도움이 돼요\'를 준다.
         * @param {GiveUpvoteRequestDto} giveUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveUpvotePost: async (giveUpvoteRequestDto: GiveUpvoteRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'giveUpvoteRequestDto' is not null or undefined
            assertParamExists('giveUpvotePost', 'giveUpvoteRequestDto', giveUpvoteRequestDto)
            const localVarPath = `/giveUpvote`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(giveUpvoteRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 챌린지에 참여한다.
         * @param {JoinChallengeRequestDto} joinChallengeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinChallengePost: async (joinChallengeRequestDto: JoinChallengeRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'joinChallengeRequestDto' is not null or undefined
            assertParamExists('joinChallengePost', 'joinChallengeRequestDto', joinChallengeRequestDto)
            const localVarPath = `/joinChallenge`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(joinChallengeRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 공개된 챌린지 리스트를 조회한다.
         * @param {ListChallengesRequestDto} listChallengesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChallengesPost: async (listChallengesRequestDto: ListChallengesRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listChallengesRequestDto' is not null or undefined
            assertParamExists('listChallengesPost', 'listChallengesRequestDto', listChallengesRequestDto)
            const localVarPath = `/listChallenges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listChallengesRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 내가 정복한 장소 목록을 조회한다.
         * @param {ListConqueredPlacesRequestDto} listConqueredPlacesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConqueredPlacesPost: async (listConqueredPlacesRequestDto: ListConqueredPlacesRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listConqueredPlacesRequestDto' is not null or undefined
            assertParamExists('listConqueredPlacesPost', 'listConqueredPlacesRequestDto', listConqueredPlacesRequestDto)
            const localVarPath = `/listConqueredPlaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listConqueredPlacesRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 즐겨찾기한 장소 목록을 조회한다.
         * @param {ListPlaceFavoritesRequestDto} listPlaceFavoritesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaceFavoritesPost: async (listPlaceFavoritesRequestDto: ListPlaceFavoritesRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listPlaceFavoritesRequestDto' is not null or undefined
            assertParamExists('listPlaceFavoritesPost', 'listPlaceFavoritesRequestDto', listPlaceFavoritesRequestDto)
            const localVarPath = `/listPlaceFavorites`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listPlaceFavoritesRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 실내 리뷰를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaceReviewsPost: async (getAccessibilityPostRequest: GetAccessibilityPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAccessibilityPostRequest' is not null or undefined
            assertParamExists('listPlaceReviewsPost', 'getAccessibilityPostRequest', getAccessibilityPostRequest)
            const localVarPath = `/listPlaceReviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAccessibilityPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * \'이 건물에 다른 점포 등록하기\'를 눌렀을 때 호출된다.
         * @summary 특정 건물의 점포를 조회한다.
         * @param {ListPlacesInBuildingPostRequest} listPlacesInBuildingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlacesInBuildingPost: async (listPlacesInBuildingPostRequest: ListPlacesInBuildingPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'listPlacesInBuildingPostRequest' is not null or undefined
            assertParamExists('listPlacesInBuildingPost', 'listPlacesInBuildingPostRequest', listPlacesInBuildingPostRequest)
            const localVarPath = `/listPlacesInBuilding`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(listPlacesInBuildingPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 음식점, 카페, 편의점, 병원 같이 키워드를 내려주면 searchPlaces 키워드로 쓸 수 있습니다.
         * @summary 특정 카테고리의 점포들을 검색할 수 있게 키워드들을 내려준다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearchKeywordsOfPlaceCategoryPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('listSearchKeywordsOfPlaceCategoryPost', 'body', body)
            const localVarPath = `/listSearchKeywordsOfPlaceCategory`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 현재는 추천 키워드만 내려준다
         * @summary 특정 조건의 검색을 할 수 있는 추천 값을 내려준다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearchPlacePresetsPost: async (body: object, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('listSearchPlacePresetsPost', 'body', body)
            const localVarPath = `/listSearchPlacePresets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 화장실 리뷰를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listToiletReviewsPost: async (getAccessibilityPostRequest: GetAccessibilityPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'getAccessibilityPostRequest' is not null or undefined
            assertParamExists('listToiletReviewsPost', 'getAccessibilityPostRequest', getAccessibilityPostRequest)
            const localVarPath = `/listToiletReviews`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(getAccessibilityPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 로그인을 한다.
         * @param {LoginPostRequest} loginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost: async (loginPostRequest: LoginPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginPostRequest' is not null or undefined
            assertParamExists('loginPost', 'loginPostRequest', loginPostRequest)
            const localVarPath = `/login`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 애플 로그인을 통해 로그인 or 회원가입을 한다.
         * @param {LoginWithAppleRequestDto} loginWithAppleRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithApplePost: async (loginWithAppleRequestDto: LoginWithAppleRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginWithAppleRequestDto' is not null or undefined
            assertParamExists('loginWithApplePost', 'loginWithAppleRequestDto', loginWithAppleRequestDto)
            const localVarPath = `/loginWithApple`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginWithAppleRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 카카오 로그인을 통해 로그인 or 회원가입을 한다.
         * @param {LoginWithKakaoPostRequest} loginWithKakaoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithKakaoPost: async (loginWithKakaoPostRequest: LoginWithKakaoPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'loginWithKakaoPostRequest' is not null or undefined
            assertParamExists('loginWithKakaoPost', 'loginWithKakaoPostRequest', loginWithKakaoPostRequest)
            const localVarPath = `/loginWithKakao`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(loginWithKakaoPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 크러셔 활동을 기록한다.
         * @param {RecordCrusherClubActivityRequestDto} recordCrusherClubActivityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordCrusherClubActivityPost: async (recordCrusherClubActivityRequestDto: RecordCrusherClubActivityRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'recordCrusherClubActivityRequestDto' is not null or undefined
            assertParamExists('recordCrusherClubActivityPost', 'recordCrusherClubActivityRequestDto', recordCrusherClubActivityRequestDto)
            const localVarPath = `/recordCrusherClubActivity`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(recordCrusherClubActivityRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 건물에 의견을 추가한다.
         * @param {RegisterBuildingAccessibilityCommentPostRequest} registerBuildingAccessibilityCommentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerBuildingAccessibilityCommentPost: async (registerBuildingAccessibilityCommentPostRequest: RegisterBuildingAccessibilityCommentPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerBuildingAccessibilityCommentPostRequest' is not null or undefined
            assertParamExists('registerBuildingAccessibilityCommentPost', 'registerBuildingAccessibilityCommentPostRequest', registerBuildingAccessibilityCommentPostRequest)
            const localVarPath = `/registerBuildingAccessibilityComment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerBuildingAccessibilityCommentPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 건물 접근성 정보를 등록한다.
         * @param {RegisterBuildingAccessibilityRequestDto} registerBuildingAccessibilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerBuildingAccessibilityPost: async (registerBuildingAccessibilityRequestDto: RegisterBuildingAccessibilityRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerBuildingAccessibilityRequestDto' is not null or undefined
            assertParamExists('registerBuildingAccessibilityPost', 'registerBuildingAccessibilityRequestDto', registerBuildingAccessibilityRequestDto)
            const localVarPath = `/registerBuildingAccessibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerBuildingAccessibilityRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 점포에 의견을 추가한다.
         * @param {RegisterPlaceAccessibilityCommentPostRequest} registerPlaceAccessibilityCommentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPlaceAccessibilityCommentPost: async (registerPlaceAccessibilityCommentPostRequest: RegisterPlaceAccessibilityCommentPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerPlaceAccessibilityCommentPostRequest' is not null or undefined
            assertParamExists('registerPlaceAccessibilityCommentPost', 'registerPlaceAccessibilityCommentPostRequest', registerPlaceAccessibilityCommentPostRequest)
            const localVarPath = `/registerPlaceAccessibilityComment`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerPlaceAccessibilityCommentPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 점포의 접근성 정보를 등록한다.
         * @param {RegisterPlaceAccessibilityRequestDto} registerPlaceAccessibilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPlaceAccessibilityPost: async (registerPlaceAccessibilityRequestDto: RegisterPlaceAccessibilityRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerPlaceAccessibilityRequestDto' is not null or undefined
            assertParamExists('registerPlaceAccessibilityPost', 'registerPlaceAccessibilityRequestDto', registerPlaceAccessibilityRequestDto)
            const localVarPath = `/registerPlaceAccessibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerPlaceAccessibilityRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 점포의 내부 및 방문 리뷰 정보를 등록한다.
         * @param {RegisterPlaceReviewRequestDto} registerPlaceReviewRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPlaceReviewPost: async (registerPlaceReviewRequestDto: RegisterPlaceReviewRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerPlaceReviewRequestDto' is not null or undefined
            assertParamExists('registerPlaceReviewPost', 'registerPlaceReviewRequestDto', registerPlaceReviewRequestDto)
            const localVarPath = `/registerPlaceReview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerPlaceReviewRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 화장실 리뷰 정보를 등록한다.
         * @param {RegisterToiletReviewRequestDto} registerToiletReviewRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerToiletReviewPost: async (registerToiletReviewRequestDto: RegisterToiletReviewRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'registerToiletReviewRequestDto' is not null or undefined
            assertParamExists('registerToiletReviewPost', 'registerToiletReviewRequestDto', registerToiletReviewRequestDto)
            const localVarPath = `/registerToiletReview`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(registerToiletReviewRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 등록된 접근성 정보, 장소 리뷰, 화장실 정보 등이 올바르지 않은 경우 신고한다.
         * @param {ReportAccessibilityPostRequest} reportAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportAccessibilityPost: async (reportAccessibilityPostRequest: ReportAccessibilityPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'reportAccessibilityPostRequest' is not null or undefined
            assertParamExists('reportAccessibilityPost', 'reportAccessibilityPostRequest', reportAccessibilityPostRequest)
            const localVarPath = `/reportAccessibility`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(reportAccessibilityPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 외부 접근성 정보가 등록된 장소를 검색한다.
         * @param {SearchExternalAccessibilitiesPostRequest} searchExternalAccessibilitiesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchExternalAccessibilitiesPost: async (searchExternalAccessibilitiesPostRequest: SearchExternalAccessibilitiesPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchExternalAccessibilitiesPostRequest' is not null or undefined
            assertParamExists('searchExternalAccessibilitiesPost', 'searchExternalAccessibilitiesPostRequest', searchExternalAccessibilitiesPostRequest)
            const localVarPath = `/searchExternalAccessibilities`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchExternalAccessibilitiesPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 점포를 검색한다. sort 가 null 인 경우에는 정확도순을 기본으로 한다.
         * @param {SearchPlacesRequestDto} searchPlacesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesPost: async (searchPlacesRequestDto: SearchPlacesRequestDto, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'searchPlacesRequestDto' is not null or undefined
            assertParamExists('searchPlacesPost', 'searchPlacesRequestDto', searchPlacesRequestDto)
            const localVarPath = `/searchPlaces`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(searchPlacesRequestDto, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 회원가입을 한다.
         * @param {SignUpPostRequest} signUpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpPost: async (signUpPostRequest: SignUpPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'signUpPostRequest' is not null or undefined
            assertParamExists('signUpPost', 'signUpPostRequest', signUpPostRequest)
            const localVarPath = `/signUp`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(signUpPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 유저의 push token 정보를 수정한다.
         * @param {UpdatePushTokenPostRequest} updatePushTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePushTokenPost: async (updatePushTokenPostRequest: UpdatePushTokenPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updatePushTokenPostRequest' is not null or undefined
            assertParamExists('updatePushTokenPost', 'updatePushTokenPostRequest', updatePushTokenPostRequest)
            const localVarPath = `/updatePushToken`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updatePushTokenPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 유저 정보를 수정한다.
         * @param {UpdateUserInfoPostRequest} updateUserInfoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInfoPost: async (updateUserInfoPostRequest: UpdateUserInfoPostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'updateUserInfoPostRequest' is not null or undefined
            assertParamExists('updateUserInfoPost', 'updateUserInfoPostRequest', updateUserInfoPostRequest)
            const localVarPath = `/updateUserInfo`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Identified required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateUserInfoPostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary 유저 프로필 정보의 유효성을 검사한다.
         * @param {ValidateUserProfilePostRequest} validateUserProfilePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateUserProfilePost: async (validateUserProfilePostRequest: ValidateUserProfilePostRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'validateUserProfilePostRequest' is not null or undefined
            assertParamExists('validateUserProfilePost', 'validateUserProfilePostRequest', validateUserProfilePostRequest)
            const localVarPath = `/validateUserProfile`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication Anonymous required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(validateUserProfilePostRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary 건물에 대해 \'이 정보가 도움이 돼요\'를 취소한다.
         * @param {CancelBuildingAccessibilityUpvoteRequestDto} cancelBuildingAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async cancelBuildingAccessibilityUpvotePost(cancelBuildingAccessibilityUpvoteRequestDto: CancelBuildingAccessibilityUpvoteRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelBuildingAccessibilityUpvotePost(cancelBuildingAccessibilityUpvoteRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 장소에 대해 \'이 정보가 도움이 돼요\'를 취소한다.
         * @param {CancelPlaceAccessibilityUpvoteRequestDto} cancelPlaceAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async cancelPlaceAccessibilityUpvotePost(cancelPlaceAccessibilityUpvoteRequestDto: CancelPlaceAccessibilityUpvoteRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelPlaceAccessibilityUpvotePost(cancelPlaceAccessibilityUpvoteRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary \'도움이 돼요\'를 취소한다.
         * @param {CancelUpvoteRequestDto} cancelUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async cancelUpvotePost(cancelUpvoteRequestDto: CancelUpvoteRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.cancelUpvotePost(cancelUpvoteRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 비회원 계정을 생성한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createAnonymousUserPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreateAnonymousUserResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createAnonymousUserPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 장소를 즐겨찾기에 추가한다.
         * @param {CreatePlaceFavoriteRequestDto} createPlaceFavoriteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPlaceFavoritePost(createPlaceFavoriteRequestDto: CreatePlaceFavoriteRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CreatePlaceFavoriteResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPlaceFavoritePost(createPlaceFavoriteRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 등록한 건물의 접근성 정보를 삭제한다. 
         * @param {DeleteBuildingAccessibilityPostRequest} deleteBuildingAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteBuildingAccessibilityPost(deleteBuildingAccessibilityPostRequest: DeleteBuildingAccessibilityPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteBuildingAccessibilityPost(deleteBuildingAccessibilityPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 등록한 장소의 접근성 정보를 삭제한다. 
         * @param {DeletePlaceAccessibilityPostRequest} deletePlaceAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaceAccessibilityPost(deletePlaceAccessibilityPostRequest: DeletePlaceAccessibilityPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaceAccessibilityPost(deletePlaceAccessibilityPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 장소를 즐겨찾기에서 삭제한다.
         * @param {DeletePlaceFavoriteRequestDto} deletePlaceFavoriteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaceFavoritePost(deletePlaceFavoriteRequestDto: DeletePlaceFavoriteRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<DeletePlaceFavoriteResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaceFavoritePost(deletePlaceFavoriteRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 등록한 장소 리뷰를 삭제한다.
         * @param {DeletePlaceReviewPostRequest} deletePlaceReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePlaceReviewPost(deletePlaceReviewPostRequest: DeletePlaceReviewPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePlaceReviewPost(deletePlaceReviewPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 등록한 화장실 리뷰를 삭제한다.
         * @param {DeleteToiletReviewPostRequest} deleteToiletReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteToiletReviewPost(deleteToiletReviewPostRequest: DeleteToiletReviewPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteToiletReviewPost(deleteToiletReviewPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 계정을 삭제한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteUserPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteUserPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 유저 접근성 정보 정복 활동을 조회한다
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessibilityActivityReportPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccessibilityActivityReportResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessibilityActivityReportPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 현재 탑 랭커들을 조회한다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessibilityLeaderboardPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccessibilityLeaderboardPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessibilityLeaderboardPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 건물 & 점포의 접근성 정보를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessibilityPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<AccessibilityInfoDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessibilityPost(getAccessibilityPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 내 현재 랭크를 조회한다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAccessibilityRankPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetAccessibilityRankPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAccessibilityRankPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 챌린지 리스트에서 공개된 챌린지를 선택해서 챌린지를 조회한다.
         * @param {GetChallengeRequestDto} getChallengeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChallengePost(getChallengeRequestDto: GetChallengeRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChallengeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChallengePost(getChallengeRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 공개되지 않은 챌린지를 초대코드를 통해 챌린지를 조회한다.
         * @param {GetChallengeWithInvitationCodeRequestDto} getChallengeWithInvitationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChallengeWithInvitationCodePost(getChallengeWithInvitationCodeRequestDto: GetChallengeWithInvitationCodeRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetChallengeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChallengeWithInvitationCodePost(getChallengeWithInvitationCodeRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 앱 버전에 따라 업데이트 상태를 알려준다
         * @param {GetClientVersionStatusRequestDto} getClientVersionStatusRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getClientVersionStatusPost(getClientVersionStatusRequestDto: GetClientVersionStatusRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetClientVersionStatusResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getClientVersionStatusPost(getClientVersionStatusRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 다음 랭크로 올라가기 위한 점수를 조회한다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCountForNextRankPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCountForNextRankPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCountForNextRankPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 현재 진행 중인 크러셔 활동 내역을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentCrusherActivityPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetCurrentCrusherActivityResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentCrusherActivityPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 공공 접근성 정보를 확인한다.
         * @param {GetExternalAccessibilityPostRequest} getExternalAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getExternalAccessibilityPost(getExternalAccessibilityPostRequest: GetExternalAccessibilityPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExternalAccessibility>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getExternalAccessibilityPost(getExternalAccessibilityPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 홈에서 보여줄 배너 정보 목록을 가져온다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHomeBanners(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetHomeBannersResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHomeBanners(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 점포 정보 등록 등의 상황에서 이미지를 업로드하기 위한 URL을 받아 온다.
         * @param {GetImageUploadUrlsPostRequest} getImageUploadUrlsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getImageUploadUrlsPost(getImageUploadUrlsPostRequest: GetImageUploadUrlsPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<GetImageUploadUrlsPost200ResponseInner>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getImageUploadUrlsPost(getImageUploadUrlsPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 주변 정복 상태를 조회한다.
         * @param {GetNearbyAccessibilityStatusPostRequest} getNearbyAccessibilityStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getNearbyAccessibilityStatusPost(getNearbyAccessibilityStatusPostRequest: GetNearbyAccessibilityStatusPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetNearbyAccessibilityStatusPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getNearbyAccessibilityStatusPost(getNearbyAccessibilityStatusPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 건물 & 점포 정보를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlaceWithBuildingPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PlaceListItem>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlaceWithBuildingPost(getAccessibilityPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 유저 정보를 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserInfoGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<GetUserInfoResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserInfoGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 건물에 대해 \'이 정보가 도움이 돼요\'를 준다.
         * @param {GiveBuildingAccessibilityUpvoteRequestDto} giveBuildingAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async giveBuildingAccessibilityUpvotePost(giveBuildingAccessibilityUpvoteRequestDto: GiveBuildingAccessibilityUpvoteRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.giveBuildingAccessibilityUpvotePost(giveBuildingAccessibilityUpvoteRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 장소에 대해 \'이 정보가 도움이 돼요\'를 준다.
         * @param {GivePlaceAccessibilityUpvoteRequestDto} givePlaceAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        async givePlaceAccessibilityUpvotePost(givePlaceAccessibilityUpvoteRequestDto: GivePlaceAccessibilityUpvoteRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.givePlaceAccessibilityUpvotePost(givePlaceAccessibilityUpvoteRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary \'도움이 돼요\'를 준다.
         * @param {GiveUpvoteRequestDto} giveUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async giveUpvotePost(giveUpvoteRequestDto: GiveUpvoteRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.giveUpvotePost(giveUpvoteRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 챌린지에 참여한다.
         * @param {JoinChallengeRequestDto} joinChallengeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async joinChallengePost(joinChallengeRequestDto: JoinChallengeRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<JoinChallengeResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.joinChallengePost(joinChallengeRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 공개된 챌린지 리스트를 조회한다.
         * @param {ListChallengesRequestDto} listChallengesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listChallengesPost(listChallengesRequestDto: ListChallengesRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListChallengesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listChallengesPost(listChallengesRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 내가 정복한 장소 목록을 조회한다.
         * @param {ListConqueredPlacesRequestDto} listConqueredPlacesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listConqueredPlacesPost(listConqueredPlacesRequestDto: ListConqueredPlacesRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListConqueredPlacesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listConqueredPlacesPost(listConqueredPlacesRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 즐겨찾기한 장소 목록을 조회한다.
         * @param {ListPlaceFavoritesRequestDto} listPlaceFavoritesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlaceFavoritesPost(listPlaceFavoritesRequestDto: ListPlaceFavoritesRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPlaceFavoritesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlaceFavoritesPost(listPlaceFavoritesRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 실내 리뷰를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlaceReviewsPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PlaceReviewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlaceReviewsPost(getAccessibilityPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * \'이 건물에 다른 점포 등록하기\'를 눌렀을 때 호출된다.
         * @summary 특정 건물의 점포를 조회한다.
         * @param {ListPlacesInBuildingPostRequest} listPlacesInBuildingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listPlacesInBuildingPost(listPlacesInBuildingPostRequest: ListPlacesInBuildingPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListPlacesInBuildingPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listPlacesInBuildingPost(listPlacesInBuildingPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 음식점, 카페, 편의점, 병원 같이 키워드를 내려주면 searchPlaces 키워드로 쓸 수 있습니다.
         * @summary 특정 카테고리의 점포들을 검색할 수 있게 키워드들을 내려준다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSearchKeywordsOfPlaceCategoryPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSearchKeywordsOfPlaceCategoryPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSearchKeywordsOfPlaceCategoryPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 현재는 추천 키워드만 내려준다
         * @summary 특정 조건의 검색을 할 수 있는 추천 값을 내려준다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listSearchPlacePresetsPost(body: object, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ListSearchPlacePresetsResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listSearchPlacePresetsPost(body, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 화장실 리뷰를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async listToiletReviewsPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ToiletReviewDto>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.listToiletReviewsPost(getAccessibilityPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 로그인을 한다.
         * @param {LoginPostRequest} loginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginPost(loginPostRequest: LoginPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginPost(loginPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 애플 로그인을 통해 로그인 or 회원가입을 한다.
         * @param {LoginWithAppleRequestDto} loginWithAppleRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginWithApplePost(loginWithAppleRequestDto: LoginWithAppleRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginWithApplePost(loginWithAppleRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 카카오 로그인을 통해 로그인 or 회원가입을 한다.
         * @param {LoginWithKakaoPostRequest} loginWithKakaoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async loginWithKakaoPost(loginWithKakaoPostRequest: LoginWithKakaoPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<LoginResultDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.loginWithKakaoPost(loginWithKakaoPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 크러셔 활동을 기록한다.
         * @param {RecordCrusherClubActivityRequestDto} recordCrusherClubActivityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async recordCrusherClubActivityPost(recordCrusherClubActivityRequestDto: RecordCrusherClubActivityRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RecordCrusherClubActivityResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.recordCrusherClubActivityPost(recordCrusherClubActivityRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 건물에 의견을 추가한다.
         * @param {RegisterBuildingAccessibilityCommentPostRequest} registerBuildingAccessibilityCommentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerBuildingAccessibilityCommentPost(registerBuildingAccessibilityCommentPostRequest: RegisterBuildingAccessibilityCommentPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterBuildingAccessibilityCommentPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerBuildingAccessibilityCommentPost(registerBuildingAccessibilityCommentPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 건물 접근성 정보를 등록한다.
         * @param {RegisterBuildingAccessibilityRequestDto} registerBuildingAccessibilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerBuildingAccessibilityPost(registerBuildingAccessibilityRequestDto: RegisterBuildingAccessibilityRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterBuildingAccessibilityResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerBuildingAccessibilityPost(registerBuildingAccessibilityRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 점포에 의견을 추가한다.
         * @param {RegisterPlaceAccessibilityCommentPostRequest} registerPlaceAccessibilityCommentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerPlaceAccessibilityCommentPost(registerPlaceAccessibilityCommentPostRequest: RegisterPlaceAccessibilityCommentPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterPlaceAccessibilityCommentPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerPlaceAccessibilityCommentPost(registerPlaceAccessibilityCommentPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 점포의 접근성 정보를 등록한다.
         * @param {RegisterPlaceAccessibilityRequestDto} registerPlaceAccessibilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerPlaceAccessibilityPost(registerPlaceAccessibilityRequestDto: RegisterPlaceAccessibilityRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterPlaceAccessibilityResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerPlaceAccessibilityPost(registerPlaceAccessibilityRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 점포의 내부 및 방문 리뷰 정보를 등록한다.
         * @param {RegisterPlaceReviewRequestDto} registerPlaceReviewRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerPlaceReviewPost(registerPlaceReviewRequestDto: RegisterPlaceReviewRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterPlaceReviewResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerPlaceReviewPost(registerPlaceReviewRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 화장실 리뷰 정보를 등록한다.
         * @param {RegisterToiletReviewRequestDto} registerToiletReviewRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registerToiletReviewPost(registerToiletReviewRequestDto: RegisterToiletReviewRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegisterToiletReviewPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registerToiletReviewPost(registerToiletReviewRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 등록된 접근성 정보, 장소 리뷰, 화장실 정보 등이 올바르지 않은 경우 신고한다.
         * @param {ReportAccessibilityPostRequest} reportAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reportAccessibilityPost(reportAccessibilityPostRequest: ReportAccessibilityPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reportAccessibilityPost(reportAccessibilityPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 외부 접근성 정보가 등록된 장소를 검색한다.
         * @param {SearchExternalAccessibilitiesPostRequest} searchExternalAccessibilitiesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchExternalAccessibilitiesPost(searchExternalAccessibilitiesPostRequest: SearchExternalAccessibilitiesPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchExternalAccessibilitiesPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchExternalAccessibilitiesPost(searchExternalAccessibilitiesPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 점포를 검색한다. sort 가 null 인 경우에는 정확도순을 기본으로 한다.
         * @param {SearchPlacesRequestDto} searchPlacesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async searchPlacesPost(searchPlacesRequestDto: SearchPlacesRequestDto, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SearchPlacesResponseDto>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.searchPlacesPost(searchPlacesRequestDto, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 회원가입을 한다.
         * @param {SignUpPostRequest} signUpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async signUpPost(signUpPostRequest: SignUpPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.signUpPost(signUpPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 유저의 push token 정보를 수정한다.
         * @param {UpdatePushTokenPostRequest} updatePushTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePushTokenPost(updatePushTokenPostRequest: UpdatePushTokenPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePushTokenPost(updatePushTokenPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 유저 정보를 수정한다.
         * @param {UpdateUserInfoPostRequest} updateUserInfoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateUserInfoPost(updateUserInfoPostRequest: UpdateUserInfoPostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UpdateUserInfoPost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateUserInfoPost(updateUserInfoPostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary 유저 프로필 정보의 유효성을 검사한다.
         * @param {ValidateUserProfilePostRequest} validateUserProfilePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async validateUserProfilePost(validateUserProfilePostRequest: ValidateUserProfilePostRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ValidateUserProfilePost200Response>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.validateUserProfilePost(validateUserProfilePostRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary 건물에 대해 \'이 정보가 도움이 돼요\'를 취소한다.
         * @param {CancelBuildingAccessibilityUpvoteRequestDto} cancelBuildingAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        cancelBuildingAccessibilityUpvotePost(cancelBuildingAccessibilityUpvoteRequestDto: CancelBuildingAccessibilityUpvoteRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.cancelBuildingAccessibilityUpvotePost(cancelBuildingAccessibilityUpvoteRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 장소에 대해 \'이 정보가 도움이 돼요\'를 취소한다.
         * @param {CancelPlaceAccessibilityUpvoteRequestDto} cancelPlaceAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        cancelPlaceAccessibilityUpvotePost(cancelPlaceAccessibilityUpvoteRequestDto: CancelPlaceAccessibilityUpvoteRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.cancelPlaceAccessibilityUpvotePost(cancelPlaceAccessibilityUpvoteRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary \'도움이 돼요\'를 취소한다.
         * @param {CancelUpvoteRequestDto} cancelUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelUpvotePost(cancelUpvoteRequestDto: CancelUpvoteRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.cancelUpvotePost(cancelUpvoteRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 비회원 계정을 생성한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createAnonymousUserPost(options?: any): AxiosPromise<CreateAnonymousUserResponseDto> {
            return localVarFp.createAnonymousUserPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 장소를 즐겨찾기에 추가한다.
         * @param {CreatePlaceFavoriteRequestDto} createPlaceFavoriteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPlaceFavoritePost(createPlaceFavoriteRequestDto: CreatePlaceFavoriteRequestDto, options?: any): AxiosPromise<CreatePlaceFavoriteResponseDto> {
            return localVarFp.createPlaceFavoritePost(createPlaceFavoriteRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 등록한 건물의 접근성 정보를 삭제한다. 
         * @param {DeleteBuildingAccessibilityPostRequest} deleteBuildingAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteBuildingAccessibilityPost(deleteBuildingAccessibilityPostRequest: DeleteBuildingAccessibilityPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.deleteBuildingAccessibilityPost(deleteBuildingAccessibilityPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 등록한 장소의 접근성 정보를 삭제한다. 
         * @param {DeletePlaceAccessibilityPostRequest} deletePlaceAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceAccessibilityPost(deletePlaceAccessibilityPostRequest: DeletePlaceAccessibilityPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.deletePlaceAccessibilityPost(deletePlaceAccessibilityPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 장소를 즐겨찾기에서 삭제한다.
         * @param {DeletePlaceFavoriteRequestDto} deletePlaceFavoriteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceFavoritePost(deletePlaceFavoriteRequestDto: DeletePlaceFavoriteRequestDto, options?: any): AxiosPromise<DeletePlaceFavoriteResponseDto> {
            return localVarFp.deletePlaceFavoritePost(deletePlaceFavoriteRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 등록한 장소 리뷰를 삭제한다.
         * @param {DeletePlaceReviewPostRequest} deletePlaceReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePlaceReviewPost(deletePlaceReviewPostRequest: DeletePlaceReviewPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.deletePlaceReviewPost(deletePlaceReviewPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 등록한 화장실 리뷰를 삭제한다.
         * @param {DeleteToiletReviewPostRequest} deleteToiletReviewPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteToiletReviewPost(deleteToiletReviewPostRequest: DeleteToiletReviewPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.deleteToiletReviewPost(deleteToiletReviewPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 계정을 삭제한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUserPost(options?: any): AxiosPromise<void> {
            return localVarFp.deleteUserPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 유저 접근성 정보 정복 활동을 조회한다
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessibilityActivityReportPost(options?: any): AxiosPromise<GetAccessibilityActivityReportResponseDto> {
            return localVarFp.getAccessibilityActivityReportPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 현재 탑 랭커들을 조회한다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessibilityLeaderboardPost(body: object, options?: any): AxiosPromise<GetAccessibilityLeaderboardPost200Response> {
            return localVarFp.getAccessibilityLeaderboardPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 건물 & 점포의 접근성 정보를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessibilityPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: any): AxiosPromise<AccessibilityInfoDto> {
            return localVarFp.getAccessibilityPost(getAccessibilityPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 내 현재 랭크를 조회한다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccessibilityRankPost(body: object, options?: any): AxiosPromise<GetAccessibilityRankPost200Response> {
            return localVarFp.getAccessibilityRankPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 챌린지 리스트에서 공개된 챌린지를 선택해서 챌린지를 조회한다.
         * @param {GetChallengeRequestDto} getChallengeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallengePost(getChallengeRequestDto: GetChallengeRequestDto, options?: any): AxiosPromise<GetChallengeResponseDto> {
            return localVarFp.getChallengePost(getChallengeRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 공개되지 않은 챌린지를 초대코드를 통해 챌린지를 조회한다.
         * @param {GetChallengeWithInvitationCodeRequestDto} getChallengeWithInvitationCodeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChallengeWithInvitationCodePost(getChallengeWithInvitationCodeRequestDto: GetChallengeWithInvitationCodeRequestDto, options?: any): AxiosPromise<GetChallengeResponseDto> {
            return localVarFp.getChallengeWithInvitationCodePost(getChallengeWithInvitationCodeRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 앱 버전에 따라 업데이트 상태를 알려준다
         * @param {GetClientVersionStatusRequestDto} getClientVersionStatusRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getClientVersionStatusPost(getClientVersionStatusRequestDto: GetClientVersionStatusRequestDto, options?: any): AxiosPromise<GetClientVersionStatusResponseDto> {
            return localVarFp.getClientVersionStatusPost(getClientVersionStatusRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 다음 랭크로 올라가기 위한 점수를 조회한다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCountForNextRankPost(body: object, options?: any): AxiosPromise<GetCountForNextRankPost200Response> {
            return localVarFp.getCountForNextRankPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 현재 진행 중인 크러셔 활동 내역을 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentCrusherActivityPost(options?: any): AxiosPromise<GetCurrentCrusherActivityResponseDto> {
            return localVarFp.getCurrentCrusherActivityPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 공공 접근성 정보를 확인한다.
         * @param {GetExternalAccessibilityPostRequest} getExternalAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getExternalAccessibilityPost(getExternalAccessibilityPostRequest: GetExternalAccessibilityPostRequest, options?: any): AxiosPromise<ExternalAccessibility> {
            return localVarFp.getExternalAccessibilityPost(getExternalAccessibilityPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 홈에서 보여줄 배너 정보 목록을 가져온다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHomeBanners(options?: any): AxiosPromise<GetHomeBannersResponseDto> {
            return localVarFp.getHomeBanners(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 점포 정보 등록 등의 상황에서 이미지를 업로드하기 위한 URL을 받아 온다.
         * @param {GetImageUploadUrlsPostRequest} getImageUploadUrlsPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getImageUploadUrlsPost(getImageUploadUrlsPostRequest: GetImageUploadUrlsPostRequest, options?: any): AxiosPromise<Array<GetImageUploadUrlsPost200ResponseInner>> {
            return localVarFp.getImageUploadUrlsPost(getImageUploadUrlsPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 주변 정복 상태를 조회한다.
         * @param {GetNearbyAccessibilityStatusPostRequest} getNearbyAccessibilityStatusPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNearbyAccessibilityStatusPost(getNearbyAccessibilityStatusPostRequest: GetNearbyAccessibilityStatusPostRequest, options?: any): AxiosPromise<GetNearbyAccessibilityStatusPost200Response> {
            return localVarFp.getNearbyAccessibilityStatusPost(getNearbyAccessibilityStatusPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 건물 & 점포 정보를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaceWithBuildingPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: any): AxiosPromise<PlaceListItem> {
            return localVarFp.getPlaceWithBuildingPost(getAccessibilityPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 유저 정보를 조회한다.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserInfoGet(options?: any): AxiosPromise<GetUserInfoResponseDto> {
            return localVarFp.getUserInfoGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 건물에 대해 \'이 정보가 도움이 돼요\'를 준다.
         * @param {GiveBuildingAccessibilityUpvoteRequestDto} giveBuildingAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        giveBuildingAccessibilityUpvotePost(giveBuildingAccessibilityUpvoteRequestDto: GiveBuildingAccessibilityUpvoteRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.giveBuildingAccessibilityUpvotePost(giveBuildingAccessibilityUpvoteRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 장소에 대해 \'이 정보가 도움이 돼요\'를 준다.
         * @param {GivePlaceAccessibilityUpvoteRequestDto} givePlaceAccessibilityUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @deprecated
         * @throws {RequiredError}
         */
        givePlaceAccessibilityUpvotePost(givePlaceAccessibilityUpvoteRequestDto: GivePlaceAccessibilityUpvoteRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.givePlaceAccessibilityUpvotePost(givePlaceAccessibilityUpvoteRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary \'도움이 돼요\'를 준다.
         * @param {GiveUpvoteRequestDto} giveUpvoteRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        giveUpvotePost(giveUpvoteRequestDto: GiveUpvoteRequestDto, options?: any): AxiosPromise<void> {
            return localVarFp.giveUpvotePost(giveUpvoteRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 챌린지에 참여한다.
         * @param {JoinChallengeRequestDto} joinChallengeRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        joinChallengePost(joinChallengeRequestDto: JoinChallengeRequestDto, options?: any): AxiosPromise<JoinChallengeResponseDto> {
            return localVarFp.joinChallengePost(joinChallengeRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 공개된 챌린지 리스트를 조회한다.
         * @param {ListChallengesRequestDto} listChallengesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listChallengesPost(listChallengesRequestDto: ListChallengesRequestDto, options?: any): AxiosPromise<ListChallengesResponseDto> {
            return localVarFp.listChallengesPost(listChallengesRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 내가 정복한 장소 목록을 조회한다.
         * @param {ListConqueredPlacesRequestDto} listConqueredPlacesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listConqueredPlacesPost(listConqueredPlacesRequestDto: ListConqueredPlacesRequestDto, options?: any): AxiosPromise<ListConqueredPlacesResponseDto> {
            return localVarFp.listConqueredPlacesPost(listConqueredPlacesRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 즐겨찾기한 장소 목록을 조회한다.
         * @param {ListPlaceFavoritesRequestDto} listPlaceFavoritesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaceFavoritesPost(listPlaceFavoritesRequestDto: ListPlaceFavoritesRequestDto, options?: any): AxiosPromise<ListPlaceFavoritesResponseDto> {
            return localVarFp.listPlaceFavoritesPost(listPlaceFavoritesRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 실내 리뷰를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlaceReviewsPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: any): AxiosPromise<Array<PlaceReviewDto>> {
            return localVarFp.listPlaceReviewsPost(getAccessibilityPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * \'이 건물에 다른 점포 등록하기\'를 눌렀을 때 호출된다.
         * @summary 특정 건물의 점포를 조회한다.
         * @param {ListPlacesInBuildingPostRequest} listPlacesInBuildingPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listPlacesInBuildingPost(listPlacesInBuildingPostRequest: ListPlacesInBuildingPostRequest, options?: any): AxiosPromise<ListPlacesInBuildingPost200Response> {
            return localVarFp.listPlacesInBuildingPost(listPlacesInBuildingPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 음식점, 카페, 편의점, 병원 같이 키워드를 내려주면 searchPlaces 키워드로 쓸 수 있습니다.
         * @summary 특정 카테고리의 점포들을 검색할 수 있게 키워드들을 내려준다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearchKeywordsOfPlaceCategoryPost(body: object, options?: any): AxiosPromise<ListSearchKeywordsOfPlaceCategoryPost200Response> {
            return localVarFp.listSearchKeywordsOfPlaceCategoryPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 현재는 추천 키워드만 내려준다
         * @summary 특정 조건의 검색을 할 수 있는 추천 값을 내려준다.
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listSearchPlacePresetsPost(body: object, options?: any): AxiosPromise<ListSearchPlacePresetsResponseDto> {
            return localVarFp.listSearchPlacePresetsPost(body, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 화장실 리뷰를 조회한다.
         * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        listToiletReviewsPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: any): AxiosPromise<Array<ToiletReviewDto>> {
            return localVarFp.listToiletReviewsPost(getAccessibilityPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 로그인을 한다.
         * @param {LoginPostRequest} loginPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginPost(loginPostRequest: LoginPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.loginPost(loginPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 애플 로그인을 통해 로그인 or 회원가입을 한다.
         * @param {LoginWithAppleRequestDto} loginWithAppleRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithApplePost(loginWithAppleRequestDto: LoginWithAppleRequestDto, options?: any): AxiosPromise<LoginResultDto> {
            return localVarFp.loginWithApplePost(loginWithAppleRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 카카오 로그인을 통해 로그인 or 회원가입을 한다.
         * @param {LoginWithKakaoPostRequest} loginWithKakaoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        loginWithKakaoPost(loginWithKakaoPostRequest: LoginWithKakaoPostRequest, options?: any): AxiosPromise<LoginResultDto> {
            return localVarFp.loginWithKakaoPost(loginWithKakaoPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 크러셔 활동을 기록한다.
         * @param {RecordCrusherClubActivityRequestDto} recordCrusherClubActivityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        recordCrusherClubActivityPost(recordCrusherClubActivityRequestDto: RecordCrusherClubActivityRequestDto, options?: any): AxiosPromise<RecordCrusherClubActivityResponseDto> {
            return localVarFp.recordCrusherClubActivityPost(recordCrusherClubActivityRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 건물에 의견을 추가한다.
         * @param {RegisterBuildingAccessibilityCommentPostRequest} registerBuildingAccessibilityCommentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerBuildingAccessibilityCommentPost(registerBuildingAccessibilityCommentPostRequest: RegisterBuildingAccessibilityCommentPostRequest, options?: any): AxiosPromise<RegisterBuildingAccessibilityCommentPost200Response> {
            return localVarFp.registerBuildingAccessibilityCommentPost(registerBuildingAccessibilityCommentPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 건물 접근성 정보를 등록한다.
         * @param {RegisterBuildingAccessibilityRequestDto} registerBuildingAccessibilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerBuildingAccessibilityPost(registerBuildingAccessibilityRequestDto: RegisterBuildingAccessibilityRequestDto, options?: any): AxiosPromise<RegisterBuildingAccessibilityResponseDto> {
            return localVarFp.registerBuildingAccessibilityPost(registerBuildingAccessibilityRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 점포에 의견을 추가한다.
         * @param {RegisterPlaceAccessibilityCommentPostRequest} registerPlaceAccessibilityCommentPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPlaceAccessibilityCommentPost(registerPlaceAccessibilityCommentPostRequest: RegisterPlaceAccessibilityCommentPostRequest, options?: any): AxiosPromise<RegisterPlaceAccessibilityCommentPost200Response> {
            return localVarFp.registerPlaceAccessibilityCommentPost(registerPlaceAccessibilityCommentPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 점포의 접근성 정보를 등록한다.
         * @param {RegisterPlaceAccessibilityRequestDto} registerPlaceAccessibilityRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPlaceAccessibilityPost(registerPlaceAccessibilityRequestDto: RegisterPlaceAccessibilityRequestDto, options?: any): AxiosPromise<RegisterPlaceAccessibilityResponseDto> {
            return localVarFp.registerPlaceAccessibilityPost(registerPlaceAccessibilityRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 점포의 내부 및 방문 리뷰 정보를 등록한다.
         * @param {RegisterPlaceReviewRequestDto} registerPlaceReviewRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerPlaceReviewPost(registerPlaceReviewRequestDto: RegisterPlaceReviewRequestDto, options?: any): AxiosPromise<RegisterPlaceReviewResponseDto> {
            return localVarFp.registerPlaceReviewPost(registerPlaceReviewRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 화장실 리뷰 정보를 등록한다.
         * @param {RegisterToiletReviewRequestDto} registerToiletReviewRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registerToiletReviewPost(registerToiletReviewRequestDto: RegisterToiletReviewRequestDto, options?: any): AxiosPromise<RegisterToiletReviewPost200Response> {
            return localVarFp.registerToiletReviewPost(registerToiletReviewRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 등록된 접근성 정보, 장소 리뷰, 화장실 정보 등이 올바르지 않은 경우 신고한다.
         * @param {ReportAccessibilityPostRequest} reportAccessibilityPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportAccessibilityPost(reportAccessibilityPostRequest: ReportAccessibilityPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.reportAccessibilityPost(reportAccessibilityPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 외부 접근성 정보가 등록된 장소를 검색한다.
         * @param {SearchExternalAccessibilitiesPostRequest} searchExternalAccessibilitiesPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchExternalAccessibilitiesPost(searchExternalAccessibilitiesPostRequest: SearchExternalAccessibilitiesPostRequest, options?: any): AxiosPromise<SearchExternalAccessibilitiesPost200Response> {
            return localVarFp.searchExternalAccessibilitiesPost(searchExternalAccessibilitiesPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 점포를 검색한다. sort 가 null 인 경우에는 정확도순을 기본으로 한다.
         * @param {SearchPlacesRequestDto} searchPlacesRequestDto 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        searchPlacesPost(searchPlacesRequestDto: SearchPlacesRequestDto, options?: any): AxiosPromise<SearchPlacesResponseDto> {
            return localVarFp.searchPlacesPost(searchPlacesRequestDto, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 회원가입을 한다.
         * @param {SignUpPostRequest} signUpPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        signUpPost(signUpPostRequest: SignUpPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.signUpPost(signUpPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 유저의 push token 정보를 수정한다.
         * @param {UpdatePushTokenPostRequest} updatePushTokenPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePushTokenPost(updatePushTokenPostRequest: UpdatePushTokenPostRequest, options?: any): AxiosPromise<void> {
            return localVarFp.updatePushTokenPost(updatePushTokenPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 유저 정보를 수정한다.
         * @param {UpdateUserInfoPostRequest} updateUserInfoPostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUserInfoPost(updateUserInfoPostRequest: UpdateUserInfoPostRequest, options?: any): AxiosPromise<UpdateUserInfoPost200Response> {
            return localVarFp.updateUserInfoPost(updateUserInfoPostRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary 유저 프로필 정보의 유효성을 검사한다.
         * @param {ValidateUserProfilePostRequest} validateUserProfilePostRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        validateUserProfilePost(validateUserProfilePostRequest: ValidateUserProfilePostRequest, options?: any): AxiosPromise<ValidateUserProfilePost200Response> {
            return localVarFp.validateUserProfilePost(validateUserProfilePostRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary 건물에 대해 \'이 정보가 도움이 돼요\'를 취소한다.
     * @param {CancelBuildingAccessibilityUpvoteRequestDto} cancelBuildingAccessibilityUpvoteRequestDto 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelBuildingAccessibilityUpvotePost(cancelBuildingAccessibilityUpvoteRequestDto: CancelBuildingAccessibilityUpvoteRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelBuildingAccessibilityUpvotePost(cancelBuildingAccessibilityUpvoteRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 장소에 대해 \'이 정보가 도움이 돼요\'를 취소한다.
     * @param {CancelPlaceAccessibilityUpvoteRequestDto} cancelPlaceAccessibilityUpvoteRequestDto 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelPlaceAccessibilityUpvotePost(cancelPlaceAccessibilityUpvoteRequestDto: CancelPlaceAccessibilityUpvoteRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelPlaceAccessibilityUpvotePost(cancelPlaceAccessibilityUpvoteRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary \'도움이 돼요\'를 취소한다.
     * @param {CancelUpvoteRequestDto} cancelUpvoteRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public cancelUpvotePost(cancelUpvoteRequestDto: CancelUpvoteRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).cancelUpvotePost(cancelUpvoteRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 비회원 계정을 생성한다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createAnonymousUserPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createAnonymousUserPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 장소를 즐겨찾기에 추가한다.
     * @param {CreatePlaceFavoriteRequestDto} createPlaceFavoriteRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public createPlaceFavoritePost(createPlaceFavoriteRequestDto: CreatePlaceFavoriteRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).createPlaceFavoritePost(createPlaceFavoriteRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 등록한 건물의 접근성 정보를 삭제한다. 
     * @param {DeleteBuildingAccessibilityPostRequest} deleteBuildingAccessibilityPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteBuildingAccessibilityPost(deleteBuildingAccessibilityPostRequest: DeleteBuildingAccessibilityPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteBuildingAccessibilityPost(deleteBuildingAccessibilityPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 등록한 장소의 접근성 정보를 삭제한다. 
     * @param {DeletePlaceAccessibilityPostRequest} deletePlaceAccessibilityPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deletePlaceAccessibilityPost(deletePlaceAccessibilityPostRequest: DeletePlaceAccessibilityPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deletePlaceAccessibilityPost(deletePlaceAccessibilityPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 장소를 즐겨찾기에서 삭제한다.
     * @param {DeletePlaceFavoriteRequestDto} deletePlaceFavoriteRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deletePlaceFavoritePost(deletePlaceFavoriteRequestDto: DeletePlaceFavoriteRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deletePlaceFavoritePost(deletePlaceFavoriteRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 등록한 장소 리뷰를 삭제한다.
     * @param {DeletePlaceReviewPostRequest} deletePlaceReviewPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deletePlaceReviewPost(deletePlaceReviewPostRequest: DeletePlaceReviewPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deletePlaceReviewPost(deletePlaceReviewPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 등록한 화장실 리뷰를 삭제한다.
     * @param {DeleteToiletReviewPostRequest} deleteToiletReviewPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteToiletReviewPost(deleteToiletReviewPostRequest: DeleteToiletReviewPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteToiletReviewPost(deleteToiletReviewPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 계정을 삭제한다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public deleteUserPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).deleteUserPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 유저 접근성 정보 정복 활동을 조회한다
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAccessibilityActivityReportPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAccessibilityActivityReportPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 현재 탑 랭커들을 조회한다.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAccessibilityLeaderboardPost(body: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAccessibilityLeaderboardPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 건물 & 점포의 접근성 정보를 조회한다.
     * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAccessibilityPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAccessibilityPost(getAccessibilityPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 내 현재 랭크를 조회한다.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getAccessibilityRankPost(body: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getAccessibilityRankPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 챌린지 리스트에서 공개된 챌린지를 선택해서 챌린지를 조회한다.
     * @param {GetChallengeRequestDto} getChallengeRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getChallengePost(getChallengeRequestDto: GetChallengeRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getChallengePost(getChallengeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 공개되지 않은 챌린지를 초대코드를 통해 챌린지를 조회한다.
     * @param {GetChallengeWithInvitationCodeRequestDto} getChallengeWithInvitationCodeRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getChallengeWithInvitationCodePost(getChallengeWithInvitationCodeRequestDto: GetChallengeWithInvitationCodeRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getChallengeWithInvitationCodePost(getChallengeWithInvitationCodeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 앱 버전에 따라 업데이트 상태를 알려준다
     * @param {GetClientVersionStatusRequestDto} getClientVersionStatusRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getClientVersionStatusPost(getClientVersionStatusRequestDto: GetClientVersionStatusRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getClientVersionStatusPost(getClientVersionStatusRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 다음 랭크로 올라가기 위한 점수를 조회한다.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCountForNextRankPost(body: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCountForNextRankPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 현재 진행 중인 크러셔 활동 내역을 조회한다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCurrentCrusherActivityPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCurrentCrusherActivityPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 공공 접근성 정보를 확인한다.
     * @param {GetExternalAccessibilityPostRequest} getExternalAccessibilityPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getExternalAccessibilityPost(getExternalAccessibilityPostRequest: GetExternalAccessibilityPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getExternalAccessibilityPost(getExternalAccessibilityPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 홈에서 보여줄 배너 정보 목록을 가져온다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHomeBanners(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getHomeBanners(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 점포 정보 등록 등의 상황에서 이미지를 업로드하기 위한 URL을 받아 온다.
     * @param {GetImageUploadUrlsPostRequest} getImageUploadUrlsPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getImageUploadUrlsPost(getImageUploadUrlsPostRequest: GetImageUploadUrlsPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getImageUploadUrlsPost(getImageUploadUrlsPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 주변 정복 상태를 조회한다.
     * @param {GetNearbyAccessibilityStatusPostRequest} getNearbyAccessibilityStatusPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getNearbyAccessibilityStatusPost(getNearbyAccessibilityStatusPostRequest: GetNearbyAccessibilityStatusPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getNearbyAccessibilityStatusPost(getNearbyAccessibilityStatusPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 건물 & 점포 정보를 조회한다.
     * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPlaceWithBuildingPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPlaceWithBuildingPost(getAccessibilityPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 유저 정보를 조회한다.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUserInfoGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUserInfoGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 건물에 대해 \'이 정보가 도움이 돼요\'를 준다.
     * @param {GiveBuildingAccessibilityUpvoteRequestDto} giveBuildingAccessibilityUpvoteRequestDto 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public giveBuildingAccessibilityUpvotePost(giveBuildingAccessibilityUpvoteRequestDto: GiveBuildingAccessibilityUpvoteRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).giveBuildingAccessibilityUpvotePost(giveBuildingAccessibilityUpvoteRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 장소에 대해 \'이 정보가 도움이 돼요\'를 준다.
     * @param {GivePlaceAccessibilityUpvoteRequestDto} givePlaceAccessibilityUpvoteRequestDto 
     * @param {*} [options] Override http request option.
     * @deprecated
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public givePlaceAccessibilityUpvotePost(givePlaceAccessibilityUpvoteRequestDto: GivePlaceAccessibilityUpvoteRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).givePlaceAccessibilityUpvotePost(givePlaceAccessibilityUpvoteRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary \'도움이 돼요\'를 준다.
     * @param {GiveUpvoteRequestDto} giveUpvoteRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public giveUpvotePost(giveUpvoteRequestDto: GiveUpvoteRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).giveUpvotePost(giveUpvoteRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 챌린지에 참여한다.
     * @param {JoinChallengeRequestDto} joinChallengeRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public joinChallengePost(joinChallengeRequestDto: JoinChallengeRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).joinChallengePost(joinChallengeRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 공개된 챌린지 리스트를 조회한다.
     * @param {ListChallengesRequestDto} listChallengesRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listChallengesPost(listChallengesRequestDto: ListChallengesRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listChallengesPost(listChallengesRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 내가 정복한 장소 목록을 조회한다.
     * @param {ListConqueredPlacesRequestDto} listConqueredPlacesRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listConqueredPlacesPost(listConqueredPlacesRequestDto: ListConqueredPlacesRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listConqueredPlacesPost(listConqueredPlacesRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 즐겨찾기한 장소 목록을 조회한다.
     * @param {ListPlaceFavoritesRequestDto} listPlaceFavoritesRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listPlaceFavoritesPost(listPlaceFavoritesRequestDto: ListPlaceFavoritesRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listPlaceFavoritesPost(listPlaceFavoritesRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 실내 리뷰를 조회한다.
     * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listPlaceReviewsPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listPlaceReviewsPost(getAccessibilityPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * \'이 건물에 다른 점포 등록하기\'를 눌렀을 때 호출된다.
     * @summary 특정 건물의 점포를 조회한다.
     * @param {ListPlacesInBuildingPostRequest} listPlacesInBuildingPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listPlacesInBuildingPost(listPlacesInBuildingPostRequest: ListPlacesInBuildingPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listPlacesInBuildingPost(listPlacesInBuildingPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 음식점, 카페, 편의점, 병원 같이 키워드를 내려주면 searchPlaces 키워드로 쓸 수 있습니다.
     * @summary 특정 카테고리의 점포들을 검색할 수 있게 키워드들을 내려준다.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSearchKeywordsOfPlaceCategoryPost(body: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listSearchKeywordsOfPlaceCategoryPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 현재는 추천 키워드만 내려준다
     * @summary 특정 조건의 검색을 할 수 있는 추천 값을 내려준다.
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listSearchPlacePresetsPost(body: object, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listSearchPlacePresetsPost(body, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 화장실 리뷰를 조회한다.
     * @param {GetAccessibilityPostRequest} getAccessibilityPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public listToiletReviewsPost(getAccessibilityPostRequest: GetAccessibilityPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).listToiletReviewsPost(getAccessibilityPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 로그인을 한다.
     * @param {LoginPostRequest} loginPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginPost(loginPostRequest: LoginPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginPost(loginPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 애플 로그인을 통해 로그인 or 회원가입을 한다.
     * @param {LoginWithAppleRequestDto} loginWithAppleRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginWithApplePost(loginWithAppleRequestDto: LoginWithAppleRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginWithApplePost(loginWithAppleRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 카카오 로그인을 통해 로그인 or 회원가입을 한다.
     * @param {LoginWithKakaoPostRequest} loginWithKakaoPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public loginWithKakaoPost(loginWithKakaoPostRequest: LoginWithKakaoPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).loginWithKakaoPost(loginWithKakaoPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 크러셔 활동을 기록한다.
     * @param {RecordCrusherClubActivityRequestDto} recordCrusherClubActivityRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public recordCrusherClubActivityPost(recordCrusherClubActivityRequestDto: RecordCrusherClubActivityRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).recordCrusherClubActivityPost(recordCrusherClubActivityRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 건물에 의견을 추가한다.
     * @param {RegisterBuildingAccessibilityCommentPostRequest} registerBuildingAccessibilityCommentPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registerBuildingAccessibilityCommentPost(registerBuildingAccessibilityCommentPostRequest: RegisterBuildingAccessibilityCommentPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).registerBuildingAccessibilityCommentPost(registerBuildingAccessibilityCommentPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 건물 접근성 정보를 등록한다.
     * @param {RegisterBuildingAccessibilityRequestDto} registerBuildingAccessibilityRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registerBuildingAccessibilityPost(registerBuildingAccessibilityRequestDto: RegisterBuildingAccessibilityRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).registerBuildingAccessibilityPost(registerBuildingAccessibilityRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 점포에 의견을 추가한다.
     * @param {RegisterPlaceAccessibilityCommentPostRequest} registerPlaceAccessibilityCommentPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registerPlaceAccessibilityCommentPost(registerPlaceAccessibilityCommentPostRequest: RegisterPlaceAccessibilityCommentPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).registerPlaceAccessibilityCommentPost(registerPlaceAccessibilityCommentPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 점포의 접근성 정보를 등록한다.
     * @param {RegisterPlaceAccessibilityRequestDto} registerPlaceAccessibilityRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registerPlaceAccessibilityPost(registerPlaceAccessibilityRequestDto: RegisterPlaceAccessibilityRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).registerPlaceAccessibilityPost(registerPlaceAccessibilityRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 점포의 내부 및 방문 리뷰 정보를 등록한다.
     * @param {RegisterPlaceReviewRequestDto} registerPlaceReviewRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registerPlaceReviewPost(registerPlaceReviewRequestDto: RegisterPlaceReviewRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).registerPlaceReviewPost(registerPlaceReviewRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 화장실 리뷰 정보를 등록한다.
     * @param {RegisterToiletReviewRequestDto} registerToiletReviewRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public registerToiletReviewPost(registerToiletReviewRequestDto: RegisterToiletReviewRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).registerToiletReviewPost(registerToiletReviewRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 등록된 접근성 정보, 장소 리뷰, 화장실 정보 등이 올바르지 않은 경우 신고한다.
     * @param {ReportAccessibilityPostRequest} reportAccessibilityPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public reportAccessibilityPost(reportAccessibilityPostRequest: ReportAccessibilityPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).reportAccessibilityPost(reportAccessibilityPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 외부 접근성 정보가 등록된 장소를 검색한다.
     * @param {SearchExternalAccessibilitiesPostRequest} searchExternalAccessibilitiesPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchExternalAccessibilitiesPost(searchExternalAccessibilitiesPostRequest: SearchExternalAccessibilitiesPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchExternalAccessibilitiesPost(searchExternalAccessibilitiesPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 점포를 검색한다. sort 가 null 인 경우에는 정확도순을 기본으로 한다.
     * @param {SearchPlacesRequestDto} searchPlacesRequestDto 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public searchPlacesPost(searchPlacesRequestDto: SearchPlacesRequestDto, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).searchPlacesPost(searchPlacesRequestDto, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 회원가입을 한다.
     * @param {SignUpPostRequest} signUpPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public signUpPost(signUpPostRequest: SignUpPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).signUpPost(signUpPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 유저의 push token 정보를 수정한다.
     * @param {UpdatePushTokenPostRequest} updatePushTokenPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updatePushTokenPost(updatePushTokenPostRequest: UpdatePushTokenPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updatePushTokenPost(updatePushTokenPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 유저 정보를 수정한다.
     * @param {UpdateUserInfoPostRequest} updateUserInfoPostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public updateUserInfoPost(updateUserInfoPostRequest: UpdateUserInfoPostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).updateUserInfoPost(updateUserInfoPostRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary 유저 프로필 정보의 유효성을 검사한다.
     * @param {ValidateUserProfilePostRequest} validateUserProfilePostRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public validateUserProfilePost(validateUserProfilePostRequest: ValidateUserProfilePostRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).validateUserProfilePost(validateUserProfilePostRequest, options).then((request) => request(this.axios, this.basePath));
    }
}


