# This file contains the fastlane.tools configuration
# You can find the documentation at https://docs.fastlane.tools
#
# For a list of all available actions, check out
#
#     https://docs.fastlane.tools/actions
#
# For a list of all available plugins, check out
#
#     https://docs.fastlane.tools/plugins/available-plugins
#

# Uncomment the line if you want fastlane to automatically update itself
# update_fastlane

default_platform(:ios)

def target_identifier(scheme:)
    case scheme
    when "sandbox"
      "club.staircrusher.sandbox"
    when "production"
      "club.staircrusher"
    end
end

def target_configuration(type:, scheme:)
    case scheme
    when "sandbox"
      "#{type}Sandbox"
    when "production"
      "#{type}"
    end
end

def target_scheme(scheme:)
    case scheme
    when "sandbox"
      "StairCrusherClubSandbox"
    when "production"
      "StairCrusherClub"
    end
end

# Get the next build number from the current bundle version
def next_build_number()
  info_plist_path = File.expand_path("../sccReactNative/Info.plist")
  current_build = get_info_plist_value(path: info_plist_path, key: 'CFBundleVersion').to_i
  return current_build + 1
end

def bundle_version()
  info_plist_path = File.expand_path("../sccReactNative/Info.plist")
  get_info_plist_value(path: info_plist_path, key: 'CFBundleVersion')
end

def git_current_branch()
  sh("git rev-parse --abbrev-ref HEAD").strip
end

def call_match(type:, api_key_path:, app_identifier:, force_for_new_devices: true, verbose: true)
  params = {
    type: type,
    api_key_path: api_key_path,
    app_identifier: app_identifier,
    force_for_new_devices: force_for_new_devices,
    verbose: verbose
  }

  # Only add keychain parameters in CI environment
  if is_ci? && ENV["KEYCHAIN_NAME"]
    params[:keychain_name] = ENV["KEYCHAIN_NAME"]
    params[:keychain_password] = ENV["KEYCHAIN_PASSWORD"]
  end

  match(params)
end

platform :ios do
  desc ""

  before_all do
    # Only create keychain in CI environment
    if is_ci?
      keychain_name = ENV["KEYCHAIN_NAME"] || "fastlane_keychain"
      keychain_password = ENV["KEYCHAIN_PASSWORD"] || ENV["MATCH_PASSWORD"] || SecureRandom.base64

      create_keychain(
        name: keychain_name,
        password: keychain_password,
        default_keychain: true,
        unlock: true,
        timeout: 7200,
        lock_when_sleeps: false
      )

      ENV["KEYCHAIN_NAME"] = keychain_name
      ENV["KEYCHAIN_PASSWORD"] = keychain_password
    end
  end

  after_all do
    # Only delete keychain in CI environment
    if is_ci? && ENV["KEYCHAIN_NAME"]
      delete_keychain(name: ENV["KEYCHAIN_NAME"])
    end
  end

  error do |lane, exception|
    # Only delete keychain in CI environment
    if is_ci? && ENV["KEYCHAIN_NAME"]
      delete_keychain(name: ENV["KEYCHAIN_NAME"])
    end
  end

  desc "Make a archive file. You can make IPA files using the archive file."
  lane :rbuild do |options|
    scheme = target_scheme(scheme: options[:scheme])
    identifier = target_identifier(scheme: options[:scheme])
    configuration = target_configuration(type: "Release", scheme: options[:scheme])
    call_match(
      type: "appstore",
      api_key_path: File.expand_path("../../subprojects/scc-frontend-build-configurations/appstore-key.json"),
      app_identifier: identifier,
      force_for_new_devices: true,
      verbose: true
    )
    build_app(
      scheme: scheme,
      configuration: configuration,
      clean: true,
      skip_package_ipa: true,
      build_path: "./build/#{options[:scheme]}"
    )
    sh("mv", "../" + lane_context[SharedValues::XCODEBUILD_ARCHIVE], "../build/#{options[:scheme]}/StairCrusherClub-#{bundle_version()}.xcarchive")
  end

  desc "Make IPA file for AppStore. It can be distributed in AppStore."
  lane :export_appstore do |options|
    scheme = target_scheme(scheme: options[:scheme])
    identifier = target_identifier(scheme: options[:scheme])
    configuration = target_configuration(type: "Release", scheme: options[:scheme])
    bundle_version = bundle_version()
    call_match(
      type: "appstore",
      api_key_path: File.expand_path("../../subprojects/scc-frontend-build-configurations/appstore-key.json"),
      app_identifier: identifier,
      force_for_new_devices: true,
      verbose: true
    )
    build_app(
      scheme: scheme,
      configuration: configuration,
      skip_build_archive: true,
      archive_path: "./build/#{options[:scheme]}/StairCrusherClub-#{bundle_version}.xcarchive",
      export_method: "app-store",
      output_directory: "./build/#{options[:scheme]}",
      output_name: "StairCrusherClub-#{bundle_version}.ipa"
    )
  end

  desc "Make IPA file for Firebase Distribution."
  lane :export_firebase do |options|
    identifier = target_identifier(scheme: options[:scheme])
    scheme = target_scheme(scheme: options[:scheme])
    configuration = target_configuration(type: "Release", scheme: options[:scheme])
    bundler_version = bundle_version()
    call_match(
      type: "adhoc",
      api_key_path: File.expand_path("../../subprojects/scc-frontend-build-configurations/appstore-key.json"),
      app_identifier: identifier,
      force_for_new_devices: true,
      verbose: true
    )
    build_app(
      scheme: scheme,
      configuration: configuration,
      skip_build_archive: true,
      archive_path: "./build/#{options[:scheme]}/StairCrusherClub-#{bundle_version}.xcarchive",
      export_method: "ad-hoc",
      output_directory: "./build/#{options[:scheme]}",
      output_name: "StairCrusherClub-Firebase-#{bundle_version}.ipa"
    )
  end

  desc "Upload IPA file to Firebase App Distribution."
  lane :firebase do |options|
    config = read_json(
      json_path: File.expand_path("../../subprojects/scc-frontend-build-configurations/#{options[:scheme]}/ios.json")
    )
    firebase_app_distribution(
      app: config[:firebase_app_id],
      firebase_cli_token: config[:firebase_cli_token],
      ipa_path: File.expand_path("../build/#{options[:scheme]}/StairCrusherClub-Firebase-#{bundle_version()}.ipa"),
      groups: "Product",
      release_notes: "Version #{options[:version]} (#{next_build_number()})"
    )
  end

  desc "Upload a IPA file to AppStoreConnect."
  lane :itc do |options|
    identifier = target_identifier(scheme: options[:scheme])
    upload_to_testflight(
      api_key_path: File.expand_path("../../subprojects/scc-frontend-build-configurations/appstore-key.json"),
      app_identifier: identifier,
      ipa: File.expand_path("../build/#{options[:scheme]}/StairCrusherClub-#{bundle_version()}.ipa"),
      beta_app_description: "계단뿌셔클럽",
      skip_waiting_for_build_processing: true
    )
  end

  desc "Ask for version, update files, commit and tag"
  lane :prepare_release do |options|
    # Skip version update if skip_version_update is true
    if options[:skip_version_update]
      UI.message("Skipping version update as requested.")
      next
    end

    # 1. 다음 버전을 묻기
    version = options[:version] || prompt(text: "What version do you want to build? ex) 0.1.4")
    unless version.to_s.strip.empty?
      matched = version.match(/([0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3})$/)
      if matched.nil?
        UI.user_error!("Version is wrong. You should specify correct version like 0.1.4, 1.13.12")
      end
    end

    # 현재 버전과 비교
    current_version = get_info_plist_value(path: File.expand_path("../sccReactNative/Info.plist"), key: 'CFBundleShortVersionString')
    if version == current_version
      UI.message("Version #{version} is the same as current version. Skipping file update and commit.")
      next
    end

    # 2. 파일 변경 (Info.plist 업데이트)
    increment_version_number(
      version_number: version
    )
    increment_build_number(
      build_number: next_build_number() + 1
    )
    # 3. commit & tag
    sh("git add ../sccReactNative/Info.plist ../sccReactNativeTests/Info.plist ../sccReactNative.xcodeproj/project.pbxproj")
    sh("git commit -m \"Release ios #{version}\"")
    tag_name = "v#{version}-ios"
    sh("git tag #{tag_name}")
    branch = git_current_branch()
    sh("git push origin #{branch}")
    sh("git push origin #{tag_name}")
  end

  desc "Make IPA files for AppStore and Firebase Distribution. After this, you can upload the ipa files to Firebase Distribution and AppStore Connect using `fastlane ios firebase` or `fastlane ios itc`"
  lane :export do |options|
    sh("rm -rf #{File.expand_path("../build/#{options[:scheme]}")}")
    rbuild(scheme: options[:scheme])
    export_appstore(scheme: options[:scheme])
    export_firebase(scheme: options[:scheme])
  end

  lane :release_candidate do |options|
    prepare_release(options)
    export(scheme: options[:scheme])
    firebase(scheme: options[:scheme])
    itc(scheme: options[:scheme])
  end
end
