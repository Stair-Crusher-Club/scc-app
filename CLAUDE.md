# Project-Specific Rules for Claude Code

## Required Post-Work Validation

After any code changes or implementation work, **ALWAYS** run these validation commands and fix all issues:

1. **ESLint Check**: `yarn lint`
   - Fix all linting errors and warnings
   - Repeat until 0 warnings/errors

2. **TypeScript Check**: `yarn tsc --noEmit`
   - Fix all type errors
   - Repeat until 0 type errors

**No task is complete until both commands pass with zero issues.**

## Project Context

- React Native application with TypeScript
- Uses ESLint for code quality
- Uses custom SccXxx components for event logging
- Implements global event logging registry for duplicate detection

## Component Guidelines

### SccXxx Components
- All touchable components must use SccXxx variants (SccPressable, SccTouchableOpacity, etc.)
- Required `elementName` prop for event logging
- Optional `logParams` for additional logging parameters
- Optional `disableLogging` prop to completely disable event logging
- Automatic duplicate element detection via global registry

### Event Logging
- `element_view` logged on component mount
- `element_click` logged on press events
- Global registry prevents duplicate elements with same elementName+params

### LogParamsProvider Pattern
섹션/화면 단위로 공통 로깅 파라미터를 하위 컴포넌트에 자동 전파할 때 사용:

```typescript
import { LogParamsProvider, useLogParams } from '@/logging/LogParamsProvider';

// 섹션 컴포넌트에서 Provider로 감싸기
export default function MySection() {
  return (
    <LogParamsProvider params={{ displaySectionName: '섹션명' }}>
      <Container>
        {/* 하위 SccPressable, SccButton 등에 자동 적용 */}
        <SccPressable elementName="my-button" logParams={{ buttonId: 1 }}>
          {/* displaySectionName이 자동으로 포함됨 */}
        </SccPressable>
      </Container>
    </LogParamsProvider>
  );
}

// 직접 Logger 호출 시 useLogParams() 사용
function ChildComponent() {
  const globalLogParams = useLogParams();

  const handleClick = () => {
    Logger.logElementClick({
      name: 'custom-event',
      currScreenName: 'MyScreen',
      extraParams: {
        ...globalLogParams,  // displaySectionName 자동 포함
        customParam: 'value',
      },
    });
  };
}
```

**핵심 규칙:**
- 개별 logParams에 displaySectionName을 직접 넣지 말고 LogParamsProvider 사용
- 중첩된 Provider에서 자식 params가 부모 params를 override
- 하위 모든 SccXxx 컴포넌트와 직접 Logger 호출에 적용됨

## API Guidelines

- Use generated API types from `src/generated-sources/openapi/` for all API responses and requests
- Always type API responses and variables explicitly
- Use React Query (`useQuery`, `useMutation`) for data fetching and mutations
- For POST/mutation requests, use the custom `@usePost.tsx` hook to handle redundant UI logic
- API errors should usually be handled with a toast for user feedback
- All API calls are processed through `@api.ts`, which is autogenerated from the OpenAPI spec
- Handle loading, error, and success states in UI components
- Never ignore API errors; provide user feedback or logging
- Keep API logic in hooks or utility functions, not in UI components
- Prefer async/await syntax for API calls

## Component Structure

- Each component should be in its own file, named after the component
- Do not separate style files; place styled components at the bottom of the file
- Always use styled-components with the `` style syntax for styling
- Prop types/interfaces should usually be inlined in the function
- Keep components focused: one responsibility per component
- Use hooks for logic, keep UI components as stateless as possible
- Export only the main component from each file

## Screen Structure

- All screens are located in `src/screens/`, each in its own directory
- Use `ScreenLayout` component as the root component for all screen components
- Set `isHeaderVisible` correctly based on navigation setup
- Enable `isKeyboardAvoidingView` for screens with text inputs
- Use `BottomSheet` component for modals, confirmations, and overlays

### ScreenLayout Usage Examples

```typescript
// Basic screen layout
export default function MyScreen() {
  return (
    <ScreenLayout isHeaderVisible={true}>
      <ScrollView>
        <YourContent />
      </ScrollView>
    </ScreenLayout>
  );
}

// Form screen with keyboard handling
export default function FormScreen() {
  return (
    <ScreenLayout 
      isHeaderVisible={true}
      isKeyboardAvoidingView={true}
      safeAreaEdges={['bottom']}>
      <ScrollView>
        <TextInput />
        <SubmitButton />
      </ScrollView>
    </ScreenLayout>
  );
}
```

### BottomSheet Usage Examples

```typescript
// Basic confirmation modal
<BottomSheet 
  isVisible={isVisible} 
  onPressBackground={handleClose}
>
  <ContentsContainer>
    <Title>Confirm Action</Title>
    <BottomSheetButtonGroup
      layout={BottomSheetButtonGroupLayout.HORIZONTAL_1X2}
      positiveButton={{
        text: "Confirm",
        onPressed: handleConfirm
      }}
      negativeButton={{
        text: "Cancel", 
        onPressed: handleCancel
      }}
    />
  </ContentsContainer>
</BottomSheet>

// Options selector
<BottomSheet isVisible={isVisible}>
  <OptionSelector>
    {options.map(option => (
      <SccButton
        key={option.id}
        text={option.text}
        onPress={() => handleSelect(option)}
        elementName={`option-${option.id}`}
      />
    ))}
  </OptionSelector>
</BottomSheet>
```

## Navigation Structure

### Adding New Screens

1. **Create screen directory structure:**
```
src/screens/
└── MyNewScreen/
    ├── index.ts              # Export screen component
    ├── MyNewScreen.tsx       # Main screen component
    └── sections/             # (Optional) Screen sections
```

2. **Define screen in Navigation.screens.ts:**
```typescript
// Import screen
import MyNewScreen, { MyNewScreenParams } from '@/screens/MyNewScreen';

// Add to ScreenParams type
export type ScreenParams = {
  MyNewScreen: MyNewScreenParams;
};

// Add to MainNavigationScreens array
export const MainNavigationScreens = [
  {
    name: 'MyNewScreen',
    component: MyNewScreen,
    options: {
      headerShown: true,
      headerTitle: '화면 제목',
      presentation: 'modal', // or 'fullScreenModal' if needed
    },
  },
];
```

3. **Create typed screen component:**
```typescript
import { ScreenProps } from '@/navigation/Navigation.screens';

export interface MyNewScreenParams {
  someId?: string;
}

export default function MyNewScreen({ 
  route, 
  navigation 
}: ScreenProps<'MyNewScreen'>) {
  const handleNavigation = useCallback(() => {
    navigation.navigate('TargetScreen', { 
      param1: 'value' 
    });
  }, [navigation]);

  return (
    <ScreenLayout isHeaderVisible={true}>
      {/* Screen content */}
    </ScreenLayout>
  );
}
```

## TypeScript Guidelines

- Always use explicit types and interfaces for props, state, and function arguments/returns
- Prefer `interface` for object shapes, especially for component props
- Use `import type` for type-only imports to optimize bundling
- Avoid using `any`; use `unknown` or proper types instead
- Use enums or union types for fixed sets of values
- Keep imports organized: external libraries first, then internal modules, then styles/assets

### TypeScript Examples

```typescript
// Component props with interface
interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
}

export default function CustomButton({ 
  title, 
  onPress, 
  variant = 'primary',
  disabled = false 
}: ButtonProps) {
  // Component implementation
}

// API response typing
import type { UserProfile, ApiResponse } from '@/generated-sources/openapi';

const { data, isLoading, error } = useQuery<ApiResponse<UserProfile>>({
  queryKey: ['user-profile', userId],
  queryFn: () => api.getUserProfile(userId),
});

// Hook with explicit return type
function useUserData(userId: string): {
  user: UserProfile | null;
  isLoading: boolean;
  error: Error | null;
} {
  // Hook implementation
  return { user, isLoading, error };
}

// Import organization
import React, { useCallback, useState } from 'react';
import { View, ScrollView } from 'react-native';
import { useQuery } from '@tanstack/react-query';

import type { UserProfile } from '@/generated-sources/openapi';
import { ScreenLayout } from '@/components/ScreenLayout';
import { api } from '@/utils/api';
```

## Component Examples

### Basic Component Structure

```typescript
import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import styled from 'styled-components/native';

interface CustomCardProps {
  title: string;
  description?: string;
  onPress?: () => void;
  variant?: 'default' | 'highlighted';
}

export default function CustomCard({ 
  title, 
  description, 
  onPress,
  variant = 'default' 
}: CustomCardProps) {
  return (
    <CardContainer variant={variant} onPress={onPress}>
      <CardTitle>{title}</CardTitle>
      {description && <CardDescription>{description}</CardDescription>}
    </CardContainer>
  );
}

// Styled components at bottom of file
const CardContainer = styled(TouchableOpacity)<{ variant: string }>`
  padding: 16px;
  border-radius: 8px;
  background-color: ${({ variant }) => 
    variant === 'highlighted' ? '#f0f8ff' : '#ffffff'
  };
  border: 1px solid #e0e0e0;
  margin-bottom: 8px;
`;

const CardTitle = styled(Text)`
  font-size: 16px;
  font-weight: 600;
  color: #333333;
`;

const CardDescription = styled(Text)`
  font-size: 14px;
  color: #666666;
  margin-top: 4px;
`;
```

### SccXxx Component Usage

```typescript
import { SccButton, SccPressable } from '@/components/atoms';

// Basic button with logging
<SccButton
  text="Submit Form"
  onPress={handleSubmit}
  elementName="submit-form-button"
  logParams={{ formType: 'user-registration' }}
/>

// Custom pressable component with logging
<SccPressable
  onPress={handleCardPress}
  elementName="user-card"
  logParams={{ userId: user.id }}
  disableLogging={isTestMode}
>
  <UserCardContent user={user} />
</SccPressable>
```

## Figma 디자인 비교 워크플로우

Android 에뮬레이터 화면과 Figma 디자인을 비교하여 구현이 디자인과 일치하는지 검증하는 워크플로우.

### 사전 요구사항

- Android 에뮬레이터 실행 중 (`adb devices`로 확인)
- Figma Desktop 앱에서 해당 디자인 노드 선택

### 비교 방법

**1. Android 스크린샷 캡처:**
```bash
adb shell screencap -p /sdcard/screen.png && adb pull /sdcard/screen.png /tmp/android-screenshot.png
```

**2. Figma 스크린샷 캡처:**
```
# Figma MCP 도구 사용
mcp__figma-dev-mode-mcp-server__get_screenshot

# 특정 노드 지정 시
mcp__figma-dev-mode-mcp-server__get_screenshot(nodeId="123:456")
```

**3. 비교 분석:**
- 두 이미지를 Read 도구로 열어 시각적 비교
- 누락된 요소, 레이아웃 차이, 스타일 불일치 확인

### 사용 가능한 Figma MCP 도구

| 도구 | 용도 |
|------|------|
| `get_screenshot` | 노드의 스크린샷 생성 |
| `get_design_context` | UI 코드 생성용 컨텍스트 (색상, 폰트, 레이아웃 등) |
| `get_variable_defs` | 디자인 변수 정의 (색상 토큰 등) |
| `get_metadata` | 노드 구조 메타데이터 (XML) |

### Two-Phase Design Implementation (필수)

디자인 구현은 반드시 **두 단계**를 거쳐야 한다:

1. **Layout Phase**: 큰 구조 (탭 분리, 섹션 순서, 컴포넌트 배치) 구현
2. **Precision Phase**: Figma `get_screenshot` + `get_design_context`로 정밀 검증
   - 색상, 폰트 사이즈/웨이트, padding/margin, 아이콘, border-radius 등 수치 대조
   - 에뮬레이터 스크린샷 vs Figma 스크린샷 비교 검증
   - 차이점 발견 시 반복 수정 (converge until match)

**Layout만 하고 "완료"라고 하지 말 것.** Precision Phase 없이는 미완성.

### 비교 체크리스트

구현 검증 시 확인할 항목:

- [ ] **레이아웃**: 요소 배치, 간격, 정렬
- [ ] **색상**: 배경색, 텍스트색, 아이콘색
- [ ] **타이포그래피**: 폰트 크기, 굵기, 행간
- [ ] **컴포넌트 존재**: 모든 UI 요소가 구현되었는지
- [ ] **상태별 UI**: 로딩, 에러, 빈 상태
- [ ] **인터랙션**: 버튼, 스크롤, 애니메이션

### 예시: HomeScreenV2 비교

```
# 1. Figma에서 HomeScreenV2 프레임 선택
# 2. Android 앱에서 홈 화면으로 이동
# 3. 비교 실행

## 발견된 차이점 예시:
| 요소 | Figma | Android | 상태 |
|------|-------|---------|------|
| 메인 배너 | ✅ | ❌ | 누락 |
| 공지사항 롤링 | ✅ | ❌ | 누락 |
| 추천 컨텐츠 | ✅ | ❌ | 누락 |
| 검색바 | ✅ | ✅ | OK |
```