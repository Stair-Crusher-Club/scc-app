# Project-Specific Rules for Claude Code

## Required Post-Work Validation

After any code changes or implementation work, **ALWAYS** run these validation commands and fix all issues:

1. **ESLint Check**: `yarn lint`
   - Fix all linting errors and warnings
   - Repeat until 0 warnings/errors

2. **TypeScript Check**: `yarn tsc --noEmit`
   - Fix all type errors
   - Repeat until 0 type errors

**No task is complete until both commands pass with zero issues.**

## Project Context

- React Native application with TypeScript
- Uses ESLint for code quality
- Uses custom SccXxx components for event logging
- Implements global event logging registry for duplicate detection

## Component Guidelines

### SccXxx Components
- All touchable components must use SccXxx variants (SccPressable, SccTouchableOpacity, etc.)
- Required `elementName` prop for event logging
- Optional `logParams` for additional logging parameters
- Optional `disableLogging` prop to completely disable event logging
- Automatic duplicate element detection via global registry

### Event Logging
- `element_view` logged on component mount
- `element_click` logged on press events
- Global registry prevents duplicate elements with same elementName+params

## API Guidelines

- Use generated API types from `src/generated-sources/openapi/` for all API responses and requests
- Always type API responses and variables explicitly
- Use React Query (`useQuery`, `useMutation`) for data fetching and mutations
- For POST/mutation requests, use the custom `@usePost.tsx` hook to handle redundant UI logic
- API errors should usually be handled with a toast for user feedback
- All API calls are processed through `@api.ts`, which is autogenerated from the OpenAPI spec
- Handle loading, error, and success states in UI components
- Never ignore API errors; provide user feedback or logging
- Keep API logic in hooks or utility functions, not in UI components
- Prefer async/await syntax for API calls

## Component Structure

- Each component should be in its own file, named after the component
- Do not separate style files; place styled components at the bottom of the file
- Always use styled-components with the `` style syntax for styling
- Prop types/interfaces should usually be inlined in the function
- Keep components focused: one responsibility per component
- Use hooks for logic, keep UI components as stateless as possible
- Export only the main component from each file

## Screen Structure

- All screens are located in `src/screens/`, each in its own directory
- Use `ScreenLayout` component as the root component for all screen components
- Set `isHeaderVisible` correctly based on navigation setup
- Enable `isKeyboardAvoidingView` for screens with text inputs
- Use `BottomSheet` component for modals, confirmations, and overlays

### ScreenLayout Usage Examples

```typescript
// Basic screen layout
export default function MyScreen() {
  return (
    <ScreenLayout isHeaderVisible={true}>
      <ScrollView>
        <YourContent />
      </ScrollView>
    </ScreenLayout>
  );
}

// Form screen with keyboard handling
export default function FormScreen() {
  return (
    <ScreenLayout 
      isHeaderVisible={true}
      isKeyboardAvoidingView={true}
      safeAreaEdges={['bottom']}>
      <ScrollView>
        <TextInput />
        <SubmitButton />
      </ScrollView>
    </ScreenLayout>
  );
}
```

### BottomSheet Usage Examples

```typescript
// Basic confirmation modal
<BottomSheet 
  isVisible={isVisible} 
  onPressBackground={handleClose}
>
  <ContentsContainer>
    <Title>Confirm Action</Title>
    <BottomSheetButtonGroup
      layout={BottomSheetButtonGroupLayout.HORIZONTAL_1X2}
      positiveButton={{
        text: "Confirm",
        onPressed: handleConfirm
      }}
      negativeButton={{
        text: "Cancel", 
        onPressed: handleCancel
      }}
    />
  </ContentsContainer>
</BottomSheet>

// Options selector
<BottomSheet isVisible={isVisible}>
  <OptionSelector>
    {options.map(option => (
      <SccButton
        key={option.id}
        text={option.text}
        onPress={() => handleSelect(option)}
        elementName={`option-${option.id}`}
      />
    ))}
  </OptionSelector>
</BottomSheet>
```

## Navigation Structure

### Adding New Screens

1. **Create screen directory structure:**
```
src/screens/
└── MyNewScreen/
    ├── index.ts              # Export screen component
    ├── MyNewScreen.tsx       # Main screen component
    └── sections/             # (Optional) Screen sections
```

2. **Define screen in Navigation.screens.ts:**
```typescript
// Import screen
import MyNewScreen, { MyNewScreenParams } from '@/screens/MyNewScreen';

// Add to ScreenParams type
export type ScreenParams = {
  MyNewScreen: MyNewScreenParams;
};

// Add to MainNavigationScreens array
export const MainNavigationScreens = [
  {
    name: 'MyNewScreen',
    component: MyNewScreen,
    options: {
      headerShown: true,
      headerTitle: '화면 제목',
      presentation: 'modal', // or 'fullScreenModal' if needed
    },
  },
];
```

3. **Create typed screen component:**
```typescript
import { ScreenProps } from '@/navigation/Navigation.screens';

export interface MyNewScreenParams {
  someId?: string;
}

export default function MyNewScreen({ 
  route, 
  navigation 
}: ScreenProps<'MyNewScreen'>) {
  const handleNavigation = useCallback(() => {
    navigation.navigate('TargetScreen', { 
      param1: 'value' 
    });
  }, [navigation]);

  return (
    <ScreenLayout isHeaderVisible={true}>
      {/* Screen content */}
    </ScreenLayout>
  );
}
```

## TypeScript Guidelines

- Always use explicit types and interfaces for props, state, and function arguments/returns
- Prefer `interface` for object shapes, especially for component props
- Use `import type` for type-only imports to optimize bundling
- Avoid using `any`; use `unknown` or proper types instead
- Use enums or union types for fixed sets of values
- Keep imports organized: external libraries first, then internal modules, then styles/assets

### TypeScript Examples

```typescript
// Component props with interface
interface ButtonProps {
  title: string;
  onPress: () => void;
  variant?: 'primary' | 'secondary';
  disabled?: boolean;
}

export default function CustomButton({ 
  title, 
  onPress, 
  variant = 'primary',
  disabled = false 
}: ButtonProps) {
  // Component implementation
}

// API response typing
import type { UserProfile, ApiResponse } from '@/generated-sources/openapi';

const { data, isLoading, error } = useQuery<ApiResponse<UserProfile>>({
  queryKey: ['user-profile', userId],
  queryFn: () => api.getUserProfile(userId),
});

// Hook with explicit return type
function useUserData(userId: string): {
  user: UserProfile | null;
  isLoading: boolean;
  error: Error | null;
} {
  // Hook implementation
  return { user, isLoading, error };
}

// Import organization
import React, { useCallback, useState } from 'react';
import { View, ScrollView } from 'react-native';
import { useQuery } from '@tanstack/react-query';

import type { UserProfile } from '@/generated-sources/openapi';
import { ScreenLayout } from '@/components/ScreenLayout';
import { api } from '@/utils/api';
```

## Component Examples

### Basic Component Structure

```typescript
import React from 'react';
import { TouchableOpacity, Text } from 'react-native';
import styled from 'styled-components/native';

interface CustomCardProps {
  title: string;
  description?: string;
  onPress?: () => void;
  variant?: 'default' | 'highlighted';
}

export default function CustomCard({ 
  title, 
  description, 
  onPress,
  variant = 'default' 
}: CustomCardProps) {
  return (
    <CardContainer variant={variant} onPress={onPress}>
      <CardTitle>{title}</CardTitle>
      {description && <CardDescription>{description}</CardDescription>}
    </CardContainer>
  );
}

// Styled components at bottom of file
const CardContainer = styled(TouchableOpacity)<{ variant: string }>`
  padding: 16px;
  border-radius: 8px;
  background-color: ${({ variant }) => 
    variant === 'highlighted' ? '#f0f8ff' : '#ffffff'
  };
  border: 1px solid #e0e0e0;
  margin-bottom: 8px;
`;

const CardTitle = styled(Text)`
  font-size: 16px;
  font-weight: 600;
  color: #333333;
`;

const CardDescription = styled(Text)`
  font-size: 14px;
  color: #666666;
  margin-top: 4px;
`;
```

### SccXxx Component Usage

```typescript
import { SccButton, SccPressable } from '@/components/atoms';

// Basic button with logging
<SccButton
  text="Submit Form"
  onPress={handleSubmit}
  elementName="submit-form-button"
  logParams={{ formType: 'user-registration' }}
/>

// Custom pressable component with logging
<SccPressable
  onPress={handleCardPress}
  elementName="user-card"
  logParams={{ userId: user.id }}
  disableLogging={isTestMode}
>
  <UserCardContent user={user} />
</SccPressable>
```